Обучение Pixi
=============

Пошаговое введение в создание игр и интерактивных медиа с
в [движком рендеринга Pixi](https://github.com/pixijs/pixi.js). **[Обновлено для Pixi v4.5.5](https://github.com/pixijs/pixi.js/releases/tag/v4.5.5)**. . Если тебе это нравится
руководство, [вам понравится книга, в которой на 80% больше контента!](http://www.springer.com/us/book/9781484210956).

### Оглавление
- [Обучение Pixi](#обучение-pixi)
    - [Оглавление](#оглавление)
  - [Вступление](#вступление)
  - [Настройка](#настройка)
    - [Установка Pixi](#установка-pixi)
  - [Создание приложения Pixi и `stage`](#создание-приложения-pixi-и-stage)
  - [Pixi спрайты](#pixi-спрайты)
  - [Загрузка изображений в кеш текстур](#загрузка-изображений-в-кеш-текстур)
  - [Отображение спрайтов](#отображение-спрайтов)
    - [Использование псевдонимов](#использование-псевдонимов)
    - [Еще немного о загрузке вещей](#еще-немного-о-загрузке-вещей)
      - [Создайте спрайт из обычного объекта изображения JavaScript или холста](#создайте-спрайт-из-обычного-объекта-изображения-javascript-или-холста)
      - [Присвоение имени загружаемому файлу](#присвоение-имени-загружаемому-файлу)
      - [Мониторинг прогресса загрузки](#мониторинг-прогресса-загрузки)
      - [Подробнее о загрузчике Pixi](#подробнее-о-загрузчике-pixi)
  - [Размещение спрайтов](#размещение-спрайтов)
  - [Размер и масштаб](#размер-и-масштаб)
  - [Rotation](#rotation)
  - [Создание спрайта из фрагмента тайлсета](#создание-спрайта-из-фрагмента-тайлсета)
  - [Использование атласа текстур](#использование-атласа-текстур)
  - [Загрузка атласа текстур](#загрузка-атласа-текстур)
  - [Создание спрайтов из загруженного атласа текстур](#создание-спрайтов-из-загруженного-атласа-текстур)
  - [Движение спрайтов](#движение-спрайтов)
  - [Использование скоростных свойств](#использование-скоростных-свойств)
  - [Игровые состояния](#игровые-состояния)
  - [движения клавиатурой](#движения-клавиатурой)
  - [Группировка спрайтов](#группировка-спрайтов)
    - [Локальная и глобальная положения](#локальная-и-глобальная-положения)
    - [Использование ParticleContainer для группировки спрайтов](#использование-particlecontainer-для-группировки-спрайтов)
  - [Графические примитивы Pixi](#графические-примитивы-pixi)
    - [Прямоугольники](#прямоугольники)
    - [Круги](#круги)
    - [Эллипсы](#эллипсы)
    - [Скругленный прямоугольник](#скругленный-прямоугольник)
    - [Lines](#lines)
    - [Polygons](#polygons)
  - [Отображение текста](#отображение-текста)
  - [Обнаружение столкновений](#обнаружение-столкновений)
    - [Функция hitTestRectangle](#функция-hittestrectangle)
  - [Пример использования: Treasure Hunter](#пример-использования-treasure-hunter)
    - [Структура кода](#структура-кода)
    - [Инициализация игры в функции setup](#инициализация-игры-в-функции-setup)
      - [Создание игровых сцен](#создание-игровых-сцен)
      - [Изготовление темницы, двери, исследователя и сокровища](#изготовление-темницы-двери-исследователя-и-сокровища)
      - [Создание монстров - капель (blob monsters)](#создание-монстров---капель-blob-monsters)
      - [Делаем полоску здоровья](#делаем-полоску-здоровья)
      - [Создание текста сообщения](#создание-текста-сообщения)
    - [Играем в игру](#играем-в-игру)
    - [Перемещение исследователя](#перемещение-исследователя)
      - [Сдерживание движения](#сдерживание-движения)
    - [Перемещение монстров](#перемещение-монстров)
    - [Проверка на столкновения](#проверка-на-столкновения)
    - [Достижение выходной двери и завершение игры](#достижение-выходной-двери-и-завершение-игры)
  - [Подробнее о спрайтах](#подробнее-о-спрайтах)
  - [Продолжая](#продолжая)
    - [Hexi](#hexi)
    - [BabylonJS](#babylonjs)
  - [Please help to support this project!](#please-help-to-support-this-project)
  i.[Hexi](#hexi)</br>
  ii.[BabylonJS](#babylonjs)</br>
25. [Поддерживая этот проект](#supportingthisproject)

<a id='introduction'></a>
Вступление
------------

Pixi - это чрезвычайно быстрый движок рендеринга 2D-спрайтов. Что это
жадный? Это означает, что он помогает отображать, анимировать и управлять
интерактивная графика, чтобы вам было легко создавать игры и
приложения, использующие
JavaScript и другие технологии HTML5. Имеет разумный,
незагроможденный API и включает множество полезных функций, таких как поддержка
текстурные атласы и обеспечение оптимизированной системы для анимации
спрайты (интерактивные изображения). Он также дает вам полный график сцены, чтобы вы могли
создавать иерархии вложенных спрайтов (спрайты внутри спрайтов), а также
позволяя прикреплять события мыши и касания непосредственно к спрайтам. А также,
большинство
что важно, Pixi старается не мешать вам, чтобы вы могли использовать как можно больше или
как можно меньше, адаптируйте его к своему личному кодированию
style и легко интегрируйте его с другими полезными фреймворками.

API Pixi на самом деле является усовершенствованной версией зашитого и проверенного в боях
API впервые был разработан Macromedia / Adobe Flash. Старые разработчики Flash
будет чувствовать себя как дома. Другие текущие фреймворки рендеринга спрайтов используют
аналогичный API: CreateJS, Starling, Sparrow и SpriteKit от Apple. В
Преимущество API Pixi в том, что он универсален: это не игра
двигатель. Это хорошо, потому что дает вам полную свободу выражения, чтобы создавать все, что вам нравится, и оборачивать это своим собственным игровым движком.

В этом уроке вы узнаете, как комбинировать Pixi
мощные функции рендеринга изображений и граф сцены, чтобы начать создавать
игры. Но Pixi не только для игр - вы можете использовать их
техники для создания любых интерактивных медиа-приложений. Это значит
приложения для телефонов!

Что вам нужно знать, прежде чем приступить к работе с этим руководством?

У вас должно быть разумное понимание HTML и JavaScript. Вам не обязательно быть экспертом, просто амбициозным новичком с желанием учиться. Если вы не знаете HTML и JavaScript,
Лучшее место для начала изучения - это эта книга:

[Foundation Game Design with HTML5 and JavaScript](https://rutracker.org/forum/viewtopic.php?t=4342415)

Я точно знаю, что это лучшая книга, потому что я ее написал!

Есть также несколько хороших интернет-ресурсов, которые помогут вам начать работу:

[Khan Academy: Computer
Programming](http://www.khanacademy.org/computing/cs)

[Code Academy:
JavaScript](http://www.codecademy.com/tracks/javascript)

Выберите то, что лучше всего подходит вашему стилю обучения.

Вы знаете, что такое переменные, функции, массивы и объекты JavaScript и как их
использовать? Знаешь что [JSON data
files](http://www.copterlabs.com/blog/json-what-it-is-how-it-works-how-to-use-it/)
are? Вы использовали [Canvas Drawing API](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Drawing_graphics_with_canvas)?

Чтобы использовать Pixi, вам также необходимо запустить веб-сервер в корневом проекте.
каталог. Вы знаете, что такое веб-сервер и как запустить один в папке вашего проекта? 
Лучше всего использовать
[node.js](http://nodejs.org) а затем установить чрезвычайно простой в использовании
[http-server](https://github.com/nodeapps/http-server). Тем не менее, если вы хотите это сделать, вам нужно чувствовать себя комфортно при работе с командной строкой Unix. Вы можете узнать, как использовать
Unix [in this video](https://www.youtube.com/watch?feature=player_embedded&v=cX9ASUE3YAQ)
and, when you're finished, follow it with [this
video](https://www.youtube.com/watch?v=INk0ATBbclc). You should learn
how to use Unix - it only takes a couple of hours to learn and is a
really fun and easy way to interact with your computer.

Но если вы пока не хотите возиться с командной строкой, попробуйте Mongoose
webserver:

[Mongoose](http://cesanta.com/mongoose.shtml)

Или просто напишите весь свой код, используя отличный [текстовый редактор 
Brackets](http://brackets.io). Brackets автоматически запускает веб-сервер
и браузер для вас, когда вы нажимаете кнопку с изображением молнии в его
основное рабочее пространство.

Теперь, если вы думаете, что готовы, читайте дальше!

(Просьба к читателям: это * живой документ *. Если у тебя есть
вопросы о конкретных деталях или необходимости разъяснения содержания, пожалуйста
создайте ** проблему ** в этом репозитории GitHub, и я обновлю текст
с дополнительной информацией.)

<a id='settingup'></a>
Настройка
----------

Прежде чем приступить к написанию кода, создайте папку для своего проекта и запустите
веб-сервер в корневом каталоге проекта. Если вы не используете
веб-сервер, Pixi не будет работать.

Далее вам необходимо установить Pixi.

<a id='installingpixi'></a>

### Установка Pixi

Версия, используемая для этого введения: **v4.5.5**
и вы можете найти файл `pixi.min.js` либо в этом репозитории в папке `pixi` либо в [Страница выпуска Pixi для версии 4.5.5](https://github.com/pixijs/pixi.js/releases/tag/v4.5.5).
Или вы можете получить последнюю версию из [Pixi's main release page](https://github.com/pixijs/pixi.js/releases).

Этот файл - все, что вам нужно для использования Pixi. Вы можете игнорировать все
другие файлы в репозитории: **они тебе не нужны.**

Затем создайте базовую HTML-страницу и используйте тэг `<script>` чтобы залинковать
файл `pixi.min.js` который только что скачали. Тэги `<script>` и `src`
должен быть относительно вашего корневого каталога, в котором находится ваш веб-сервер
Бег. Ваш тэг `<script>` может выглядеть примерно так:

```html
<script src="pixi.min.js"></script>
```

Вот базовая HTML-страница, которую вы можете использовать, чтобы связать Pixi и протестировать ее.
это работает. (Предполагается, что `pixi.min.js` находится в подпапке с именем `pixi`.):

```html
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Hello World</title>
</head>
  <script src="pixi/pixi.min.js"></script>
<body>
  <script type="text/javascript">
    let type = "WebGL"
    if(!PIXI.utils.isWebGLSupported()){
      type = "canvas"
    }

    PIXI.utils.sayHello(type)
  </script>
</body>
</html>
```

Если Pixi подключается правильно,
что-то вроде этого будет отображаться в консоли JavaScript вашего веб-браузера по умолчанию:

```
      PixiJS 4.4.5 - * canvas * http://www.pixijs.com/  ♥♥♥ 
```

<a id='application'></a>
Создание приложения Pixi и `stage`
----------------------------------

Теперь вы можете начать использовать Pixi!

Но как?

Первый шаг - создать прямоугольную
область отображения, в которой можно начать отображение изображений. 
У Pixi есть объект ʻApplication`, который создает это за вас. 
Он автоматически генерирует HTML-элемент <canvas> и определяет, как
отображать ваши изображения на холсте. Затем вам нужно создать
специальный объект Pixi `Container` под названием` stage`. Как вы увидите
далее этот объект `stage` будет использоваться как корневой контейнер
который содержит все, что вы хотите, чтобы Pixi отображала.

Вот код, который вам нужно написать, чтобы создать `app` Pixi Application
и `stage`. Добавьте этот код в свой HTML-документ между тэгами `<script>`:

```js
//Создать приложение Pixi
let app = new PIXI.Application({width: 256, height: 256});

//Добавьте холст, который Pixi автоматически создал для вас, в HTML-документ.
document.body.appendChild(app.view);
```

Это самый простой код, который вам нужно написать, чтобы начать использовать Pixi.
Он создает черный элемент холста размером 256 на 256 пикселей и добавляет его в ваш
HTML-документ. Вот как это выглядит в браузере при запуске этого кода.

![Базовый экран](/examples/images/screenshots/01.png)

Вау [черный квадрат](http://rampantgames.com/blog/?p=7745)!

`PIXI.Application` выясняет, использовать ли Canvas Drawing API или WebGL для рендеринга графики, в зависимости от того, что доступно в используемом вами веб-браузере. Его аргумент - это единственный объект, называемый объектом `options`.
В этом примере его `width` и `height` свойства установлены для определения ширины и высоты холста в пикселях. Вы можете установить еще много дополнительных свойств внутри этого объекта `options`;
вот как вы можете использовать его для настройки сглаживания, прозрачности и разрешения:

```js
let app = new PIXI.Application({ 
    width: 256,         // default: 800
    height: 256,        // default: 600
    antialias: true,    // default: false
    transparent: false, // default: false
    resolution: 1       // default: 1
  }
);
```

Если вас устраивают настройки Pixi по умолчанию, вам не нужно устанавливать какие-либо из этих параметров.
Bно, если вам нужно, см. документацию Pixi на [PIXI.Application](http://pixijs.download/release/docs/PIXI.Application.html).

Что делают эти варианты?
`antialias` сглаживает края шрифтов и графических примитивов. (WebGL
сглаживание доступно не на всех платформах, поэтому вам необходимо протестировать
это на целевой платформе вашей игры.) `transparent` делает холст
фон прозрачный. `resolution` облегчает работу с
дисплеи с различным разрешением и плотностью пикселей.
Настройка разрешений немного выходит за рамки этого руководства,
но проверьте [Объяснение Мэта Гроува](http://www.goodboydigital.com/pixi-js-v2-fastest-2d-webgl-renderer/) о том, как использовать `resolution` для всех деталей.
Но обычно для большинства проектов просто держите значение «разрешение» равным 1, и все будет в порядке.

Объект Pixi `renderer` по умолчанию будет использовать WebGL, что хорошо, потому что WebGL
невероятно быстр и позволяет использовать впечатляющие визуальные эффекты,
вы узнаете все в будущем.
Но если вам нужно заставить Canvas Drawing API rendering поверх WebGL,
вы можете установить опцию `forceCanvas` в `true`, вот так:

```js
forceCanvas: true,
```

Если вам нужно изменить цвет фона холста после того, как вы
создал его, установите свойство `backgroundColor` объекта `app.renderer`
в любое шестнадцатеричное значение цвета:

```js
app.renderer.backgroundColor = 0x061639;
```

Если вы хотите найти ширину или высоту `renderer`, используйте
`app.renderer.view.width` и `app.renderer.view.height`.

Чтобы изменить размер canvas, используйте метод `renderer` `resize`
, и передайте любые новые значения `width` и `height`. Но чтобы сделать
убедитесь, что размер холста изменен в соответствии с разрешением,
установите `autoResize` в `true`.

```js
app.renderer.autoResize = true;
app.renderer.resize(512, 512);
```

Если вы хотите, чтобы холст заполнял все окно, вы можете применить это
Стилизацией CSS и изменением размера рендера до размера окна браузера..

```
app.renderer.view.style.position = "absolute";
app.renderer.view.style.display = "block";
app.renderer.autoResize = true;
app.renderer.resize(window.innerWidth, window.innerHeight);
```

Но, если вы это сделаете, убедитесь, что вы также установили отступы по умолчанию и
поля до 0 для всех ваших HTML-элементов с помощью этого фрагмента кода CSS:

```html
<style>* {padding: 0; margin: 0}</style>
```

(Звездочка, *, в коде выше, в CSS это "универсальный селектор",
который просто означает "все теги в HTML-документе".)

Если вы хотите, чтобы холст масштабировался пропорционально любому окну браузера
размер, вы можете использовать[эту подстройку функции `scaleToWindow`](https://github.com/kittykatattack/scaleToWindow).

<a id='sprites'></a>
Pixi спрайты
------------

Теперь, когда у вас есть средство визуализации, вы можете начать добавлять в него изображения.
Все, что вы хотите сделать видимым в рендерере, необходимо добавить в специальный объект Pixi, называемый `stage` (deprecated, с версии 5 это теперь PIXI.container). Вы можете получить доступ к этому специальному объекту `stage` так:

```js
app.stage
```

`stage` это Pixi объект `Container`. Вы можете думать о контейнере
как своего рода пустую коробку, которая будет группироваться и хранить все, что вы
положить внутрь.
Объект `stage` - это корневой контейнер для всех видимых
вещей в вашей сцене.
Все, что вы поместите в `stage`, будет на холсте. Сейчас `stage` пуста, но скоро мы собираемся
начать класть вещи в нее. (Вы можете узнать больше об объектах Pixi `Container` [здесь](http://pixijs.download/release/docs/PIXI.Container.html)).

(Важно: поскольку `stage` это Pixi `Container` он имеет те же свойства и методы, что и любой другой объект`Container`. Но, хотя `stage` имеет свойства `width` и `height`, *они не относятся к
размеру окна рендеринга*. `width` и `height` сцены это просто площадь, занимаемая предметами, которые вы поместили внутрь - подробнее об этом впереди!)

Так что вы можете поместить на сцену? Специальные объекты изображения, называемые
**sprites**. Спрайты - это просто изображения, которыми вы можете управлять.
в коде. Вы можете контролировать их положение, размер и множество других свойств, 
которые полезны для создания интерактивной и анимированной графики.
Научиться создавать и контролировать спрайты - действительно самая важная вещь 
в обучении использованию Pixi.

В Pixi есть класс `Sprite`, который является универсальным способом создания игры.
Есть три основных способа их создания:

- Из одного файла изображения.
- Из суб-изображений в **tileset**. Набор плиток - это одно большое изображение, которое
включает все изображения, которые вам понадобятся в вашей игре.
- Из **texture atlas** (Файл JSON, определяющий размер и положение изображения на тайлсете.)

Вы собираетесь изучить все три способа, но прежде давайте найдем
что вам нужно знать об изображениях, прежде чем вы сможете их отображать
с Pixi.

<a id='loading'></a>
Загрузка изображений в кеш текстур
-------------------------------------

Поскольку Pixi отображает изображение на GPU с помощью WebGL, изображение требует
быть в формате, который GPU может обрабатывать. Готовое к WebGL изображение
называется **texture**. Прежде чем вы сможете заставить спрайт отображать изображение,
вам нужно преобразовать обычный файл изображения в текстуру WebGL.
Чтобы все работало быстро и эффективно, Pixi использует
**кэш текстур** для хранения и ссылки на все текстуры для ваших спрайтов.
Имена текстур представляют собой строки, соответствующие расположению файлов изображений, к которым они относятся.
Это означает, что если у вас есть текстура, загруженная из «images/cat.png», вы можете найти ее в кеше текстур, так:

```js
PIXI.utils.TextureCache["images/cat.png"];
```

Текстуры хранятся в формате, совместимом с WebGL, что эффективно для работы рендерера Pixi с ним. Затем вы можете использовать класс Pixi `Sprite`, чтобы создать новый спрайт с использованием текстуры.

```js
let texture = PIXI.utils.TextureCache["images/anySpriteImage.png"];
let sprite = new PIXI.Sprite(texture);
```

Но как загрузить файл изображения и преобразовать его в текстуру?
Используйте встроенный в Pixi объект `loader`.

Мощный Pixi объект `loader` это все, что вам нужно для загрузки любого изображения.
Вот как с его помощью загрузить изображение и вызвать функцию с именем `setup` когда изображение закончило загрузку:

```js
PIXI.loader
  .add("images/anyImage.png")
  .load(setup);

function setup() {
  //Этот код будет запущен, когда загрузчик закончит загрузку изображения.
}
```

[Команда разработчиков Pixi рекомендует](http://www.html5gamedevs.com/topic/16019-preload-all-textures/?p=90907)
что если вы используете загрузчик, вы должны создать спрайт с помощью
ссылки на текстуру в `resources` объекта `loader` , вот так:

```js
let sprite = new PIXI.Sprite(
  PIXI.loader.resources["images/anyImage.png"].texture
);
```

Вот пример полного кода, который вы можете написать для загрузки изображения,
вызвать функцию `setup` и создать спрайт из загруженного изображения:

```js
PIXI.loader
  .add("images/anyImage.png")
  .load(setup);

function setup() {
  let sprite = new PIXI.Sprite(
    PIXI.loader.resources["images/anyImage.png"].texture
  );
}
```

Это общий формат, который мы будем использовать для загрузки изображений и создания
спрайтов в этом уроке.

Вы можете загрузить несколько изображений одновременно, перечислив их с помощью
цепочки методов `add` , вот так:

```js

PIXI.loader
  .add("images/imageOne.png")
  .add("images/imageTwo.png")
  .add("images/imageThree.png")
  .load(setup);
```

А еще лучше просто перечислите все файлы, которые хотите загрузить.
массивом внутри одного `add` метода, вот так:

```js
PIXI.loader
  .add([
    "images/imageOne.png",
    "images/imageTwo.png",
    "images/imageThree.png"
  ])
  .load(setup);
```

`loader` также позволяет загружать файлы JSON, о чем вы узнаете позже.

<a id='displaying'></a>

Отображение спрайтов
--------------------

После того, как вы загрузили изображение и использовали его для создания спрайта, вам нужно добавить спрайт на сцену `stage` Pixi методом `stage.addChild` вот так:

```js
app.stage.addChild(cat);
```

Помните, что `stage` это основной контейнер, в котором хранятся все ваши спрайты.

**Важно: вы не сможете увидеть свои спрайты, если не добавите их в `stage`!**

Прежде чем продолжить, давайте рассмотрим практический пример того, как использовать то, что
вы только что научились отображать одно изображение. В папке `examples/images`
вы найдете изображение кота в формате PNG размером 64 на 64 пискеля.

![Basic display](/examples/images/cat.png)

Вот весь код JavaScript, необходимый для загрузки изображения, создания
спрайта и отображения его на сцене Pixi:

```js
//Создать приложение Pixi
let app = new PIXI.Application({
    width: 256,
    height: 256,
    antialias: true,
    transparent: false,
    resolution: 1
  }
);

//Добавьте холст, который Pixi автоматически создал для вас, в HTML-документ.
document.body.appendChild(app.view);

//загрузите изображение и запустите функцию `setup`, когда это будет сделано
PIXI.loader
  .add("images/cat.png")
  .load(setup);

//Эта функция `setup` запускается, когда изображение загружено.
function setup() {

  //Создайте спрайт кошки
  let cat = new PIXI.Sprite(PIXI.loader.resources["images/cat.png"].texture);
  
  //Добавьте кота на сцену
  app.stage.addChild(cat);
}
```

Когда этот код запустится, вы увидите следующее:

![Cat on the stage](/examples/images/screenshots/02.png)

Теперь мы куда-то идем!

Если вам когда-нибудь понадобится удалить спрайт со сцены, используйте метод `removeChild`:

```js
app.stage.removeChild(anySprite)
```

Но обычно установка свойства спрайта `visible` в `false` будет более простым и эффективным способом заставить спрайты исчезнуть.

```js
anySprite.visible = false;
```

<a id='usingaliases'></a>

### Использование псевдонимов

Вы можете сэкономить немного времени на вводе текста и сделать свой код более читабельным
создавая короткие псевдонимы для объектов и методов Pixi, которые вы часто
используете.
Например, вас утомляет добавление префикса `PIXI` ко всем объектам Pixi? Если вы так думаете, создайте более короткий псевдоним, указывающий на него.
Например, вот как вы можете создать псевдоним для объекта `TextureCache`:

```js
let TextureCache = PIXI.utils.TextureCache
```

Затем используйте этот псевдоним вместо оригинала, например:

```js
let texture = TextureCache["images/cat.png"];
```

Помимо возможности писать более сжатый код, использование псевдонимов имеет
дополнительное преимущество: это помогает защитить вас от частых
изменение API.
Если API Pixi изменится в будущем
версии - что будет! - вам просто нужно обновить эти псевдонимы до
Объекты и методы Pixi в одном месте, в начале
ваша программа, а не каждый экземпляр, где они используются
ваш код. Поэтому, когда команда разработчиков Pixi решает, что они хотят
Немного переставьте мебель, вы будете на шаг впереди них!

Чтобы увидеть, как это сделать, давайте перепишем написанный нами код для загрузки изображения и его отображения.
используя псевдонимы для всех объектов и методов Pixi.

```js
//Псевдонимы
let Application = PIXI.Application,
    loader = PIXI.loader,
    resources = PIXI.loader.resources,
    Sprite = PIXI.Sprite;

//Создать приложение Pixi
let app = new Application({
    width: 256,
    height: 256,
    antialias: true,
    transparent: false,
    resolution: 1
  }
);

//Добавьте холст, который Pixi автоматически создал для вас, в HTML-документ.
document.body.appendChild(app.view);

//загрузите изображение и запустите функцию `setup`, когда это будет сделано
loader
  .add("images/cat.png")
  .load(setup);

//Эта функция `setup` запускается, когда изображение загружено.
function setup() {

  //Создайте спрайт кошки
  let cat = new Sprite(resources["images/cat.png"].texture);
  
  //Добавьте кота на сцену
  app.stage.addChild(cat);
}

```

В большинстве примеров в этом руководстве будут использоваться псевдонимы для Pixi.
объекты, которые следуют этой же модели. **Если не указано иное, вы можете предположим, что все последующие примеры кода используют псевдонимы, подобные этим**.

Это все, что вам нужно знать, чтобы начать загружать изображения и создавать
спрайты.

<a id='alittlemoreaboutloadingthings'></a>

### Еще немного о загрузке вещей

Формат, который я показал вам выше, я предлагаю вам использовать в качестве
стандартный шаблон для загрузки изображений и отображения спрайтов. Так что вы
можете спокойно игнорировать следующие несколько абзацев и сразу перейти к
следующему разделу «Размещение спрайтов». Но объект загрузчика Pixi
довольно сложный и включает в себя несколько функций, которыми вы должны быть
осведомлены, даже если вы не используете их на регулярной основе. Давайте
посмотрите на некоторые из самых полезных.

<a id='makeaspritefromanordinaryjavascriptimageobject'></a>

#### Создайте спрайт из обычного объекта изображения JavaScript или холста

Для оптимизации и повышения эффективности всегда лучше создавать спрайт из
текстуры, которая была предварительно загружена в кеш текстур Pixi. Но если
почему-то вам нужно сделать текстуру из обычного объекта JavaScript `Image`,
вы можете сделать это используя классы Pixi `BaseTexture` и `Texture`:

```js
let base = new PIXI.BaseTexture(anyImageObject),
    texture = new PIXI.Texture(base),
    sprite = new PIXI.Sprite(texture);
```

Вы можете использовать `BaseTexture.fromCanvas` если вы хотите сделать текстуру
из любого существующего элемента холста:

```js
let base = new PIXI.BaseTexture.fromCanvas(anyCanvasElement),
```

Если вы хотите изменить текстуру, отображаемую спрайтом, используйте
свойство `texture`. Установите его на любой объект `Текстура`, например:

```js
anySprite.texture = PIXI.utils.TextureCache["anyTexture.png"];
```

Вы можете использовать эту технику для интерактивного изменения спрайта
внешний вид, если с ним в игре произойдет что-то существенное.

<a id='assigninganametoaloadingfile'></a>

#### Присвоение имени загружаемому файлу

Каждому ресурсу можно присвоить уникальное имя.
грузить.
Просто укажите имя (строку) в качестве первого аргумента в методе `add`.
Например, вот как назвать изображение кошки как `catImage`.

```js
PIXI.loader
  .add("catImage", "images/cat.png")
  .load(setup);
```

Это создает объект с именем `catImage` в `loader.resources`.
Это означает, что вы можете создать спрайт, обратившись к объект `catImage`, вот так:

```js
let cat = new PIXI.Sprite(PIXI.loader.resources.catImage.texture);
```

Однако я рекомендую вам не использовать эту функцию!
Это потому, что вам нужно запомнить все имена, которые вы дали каждому загруженному файлу,
а также убедитесь, что вы случайно не используете одно и то же имя более одного раза.
Использование имени пути к файлу, как мы делали в предыдущих примерах, проще и менее подвержено ошибкам..

<a id='monitoringloadprogress'></a>

#### Мониторинг прогресса загрузки

В загрузчике Pixi есть специальное событие `progress`, которое вызывает
настраиваемая функция, которая будет запускаться каждый раз при загрузке файла.
События `progress` вызываются методом `on` объекта `loader`, вот так:

```js
PIXI.loader.on("progress", loadProgressHandler);
```

Вот как включить метод `on` в цепочку загрузки и вызвать определяемая
пользователем функция, называемая `loadProgressHandler` каждый раз,
когда файл загружается.

```js
PIXI.loader
  .add([
    "images/one.png",
    "images/two.png",
    "images/three.png"
  ])
  .on("progress", loadProgressHandler)
  .load(setup);

function loadProgressHandler() {
  console.log("loading");
}

function setup() {
  console.log("setup");
}
```

Каждый раз, когда загружается один из файлов, событие progress вызывает
`loadProgressHandler` для отображения "loading" в консоли.
Когда все три файла загружены, функция setup будет запущена.
Вот вывод вышеприведенного кода в консоли:

```js
loading
loading
loading
setup
```

Это здорово, но становится лучше. Вы также можете узнать, какой именно файл
загружен, и какой процент файлов в настоящее время загружен.
Вы можете сделать это, добавив необязательные `loader` и
`resource` параметры к `loadProgressHandler`, вот так:

```js
function loadProgressHandler(loader, resource) { /*...*/ }
```

Затем вы можете использовать `resource.url` чтобы найти текущий файл
загрузки. (Используйте `resource.name` если вы хотите найти необязательное имя
что вы могли назначить файлу, как первый аргумент в методе
`add`.) И вы можете использовать `loader.progress` для поиска
процента от общих ресурсов загрузки.
Вот код, который это делает.

```js
PIXI.loader
  .add([
    "images/one.png",
    "images/two.png",
    "images/three.png"
  ])
  .on("progress", loadProgressHandler)
  .load(setup);

function loadProgressHandler(loader, resource) {

  // Отобразить загружаемый в данный момент файл url
  console.log("loading: " + resource.url);

  // Показать процент загруженных файлов
  console.log("progress: " + loader.progress + "%");

  // Если вы указали имена файлов в качестве первого аргумента метода ʻadd`,
  // вы можете получить к ним доступ следующим образом
  // console.log("loading: " + resource.name);
}

function setup() {
  console.log("All files loaded");
}
```

Вот что этот код будет отображать в консоли при запуске:

```js
loading: images/one.png
progress: 33.333333333333336%
loading: images/two.png
progress: 66.66666666666667%
loading: images/three.png
progress: 100%
All files loaded
```

Это действительно здорово, потому что вы можете использовать это как основу для
создание индикатора выполнения загрузки.

(Note: Есть дополнительные свойства, к которым вы можете получить доступ на
объект `resource`. `resource.error` расскажет вам о любых возможных
ошибках, произошедших во время попытки загрузить файл. `resource.data` открывает вам
доступ к необработанным двоичным данным файла.)

<a id='moreaboutpixisloader'></a>

#### Подробнее о загрузчике Pixi

Загрузчик Pixi невероятно многофункциональный и настраиваемый. Давайте
взгляните на его использование с высоты птичьего полета, чтобы
начать.

Цепной метод ʻadd` загрузчика принимает 4 основных аргумента.:

```js
add(name, url, optionObject, callbackFunction)
```

Вот что говорится в документации по исходному коду загрузчика
эти параметры:

`name` (string): Имя загружаемого ресурса. Если он не передан, используется url.
`url` (string): URL-адрес этого ресурса относительно baseUrl загрузчика.
`options` (object literal): Варианты загрузки.
`options.crossOrigin` (Boolean): Является ли запрос кросс-источником? По умолчанию определяется автоматически.
`options.loadType`: Как следует загружать ресурс? Значение по умолчанию - `Resource.LOAD_TYPE.XHR`.
`options.xhrType`: Как следует интерпретировать загружаемые данные
при использовании XHR? Значение по умолчанию - `Resource.XHR_RESPONSE_TYPE.DEFAULT`
`callbackFunction`: Функция, вызываемая, когда этот конкретный ресурс завершает загрузку.

Единственный из этих обязательных аргументов - `url` (файл, который вы хотите загрузить).

Вот несколько примеров того, как можно использовать метод `add` для загрузки файла. Эти первые - это то, что в документации называется "нормальным синтаксисом" загрузчика.:

```js
.add('key', 'http://...', function () {})
.add('http://...', function () {})
.add('http://...')
```

А это примеры "объектного синтаксиса" загрузчика.:

```js
.add({
  name: 'key2',
  url: 'http://...'
}, function () {})

.add({
  url: 'http://...'
}, function () {})

.add({
  name: 'key3',
  url: 'http://...'
  onComplete: function () {}
})

.add({
  url: 'https://...',
  onComplete: function () {},
  crossOrigin: true
})
```

Вы также можете передать методу `add` массив объектов, или urls, или оба:

```js
.add([
  {name: 'key4', url: 'http://...', onComplete: function () {} },
  {url: 'http://...', onComplete: function () {} },
  'http://...'
]);
```

(Note: Если вам когда-нибудь понадобится перезагрузить загрузчик, чтобы загрузить новый пакет файлов, вызовите метод загрузчика `reset`: `PIXI.loader.reset();`)

Загрузчик Pixi имеет множество дополнительных функций, в том числе
позволяет загружать и анализировать двоичные файлы всех типов. Это не
то, что вам нужно делать изо дня в день, и выходит за рамки этого руководства,
так что [не забудьте проверить репозиторий загрузчика на GitHub
Чтобы получить больше информации](https://github.com/englercj/resource-loader).

<a id='positioning'></a>
Размещение спрайтов
-------------------

Теперь, когда вы знаете, как создавать и отображать спрайты, давайте узнаем
как их расположить и изменить размер.

В предыдущем примере спрайт кошки был добавлен на сцену в
верхний левый угол. У кота есть `x` позложение равное 0 и
`y` положение равное 0.
Вы можете изменить положение кошки, измененяя значения его свойств `x` и` y`.
Вот как можно центрировать кошку на сцене, установите значения свойств `x` и` y` на 96.

```js
cat.x = 96;
cat.y = 96;
```

Добавьте эти две строки кода в любое место внутри функции
`setup`, после того, как вы создали спрайт.

```js
function setup() {

  //Создание спрайта `cat`
  let cat = new Sprite(resources["images/cat.png"].texture);

  //Измените положение спрайта
  cat.x = 96;
  cat.y = 96;

  //Добавьте кота на сцену, чтобы вы его видели
  app.stage.addChild(cat);
}
```

(Note: В этом примере,
`Sprite` это псевдоним для `PIXI.Sprite`, `TextureCache` является
псевдонимом для `PIXI.utils.TextureCache`, а `resources` это псевдоним для
`PIXI.loader.resources` как описано ранее.
Я буду использовать псевдонимы в том же формате для всех объектов Pixi и
методы в примере кода с этого момента.)

Эти две новые строки кода переместят кота на 96 пикселей вправо,
и 96 пикселей вниз. Вот результат:

![Cat центрирован на сцене](/examples/images/screenshots/03.png)

Левый верхний угол кошки (левое ухо) представляет ее `x` и `y`.
точка привязки. Чтобы кошка двигалась вправо, увеличьте
значение его свойства `x`. Чтобы кошка двигалась вниз, увеличьте
значение его свойства `y`. Если у кота значение `x` равно 0, оно будет на
самой левой стороне сцены. Если он имеет значение `y`, равное 0, он будет
на самом верху сцены.

![Cat центрирован на сцене - diagram](/examples/images/screenshots/04.png)

Вместо того, чтобы устанавливать свойства спрайта `x` и` y` независимо друг от друга,
вы можете установить их вместе в одной строке кода, например:

```js
sprite.position.set(x, y)
```

<a id='sizenscale'></a>
Размер и масштаб
----------------

Вы можете изменить размер спрайта, установив его свойства `width` и `height`. Вот как задать кошке `width`  80 пикселей и `height` 20 пикселей.

```js
cat.width = 80;
cat.height = 120;
```

Добавьте эти две строки кода в функцию `setup`, вот так:

```js
function setup() {

  //Создайте спрайт `cat`
  let cat = new Sprite(resources["images/cat.png"].texture);

  //Измените положение спрайта
  cat.x = 96;
  cat.y = 96;

  //Изменить размер спрайта
  cat.width = 80;
  cat.height = 120;

  //Добавьте кота на сцену, чтобы вы его видели
  app.stage.addChild(cat);
}
```

Вот результат:

![Высота и ширина кошки изменены](/examples/images/screenshots/05.png)

Вы можете видеть, что положение кошки (ее левый верхний угол) не изменилось.
меняем только его ширину и высоту.

![Высота и ширина кота изменены - диаграмма](/examples/images/screenshots/06.png)

Спрайты также имеют свойства `scale.x` и `scale.y` которые меняют
ширина и высота спрайта пропорциональны. Вот как настроить кошачий
масштабировать до половины размера:

```js
cat.scale.x = 0.5;
cat.scale.y = 0.5;
```

значения Scale - это числа от 0 до 1, которые представляют
процент от размера спрайта. 1 означает 100% (полный размер), а
0,5 означает 50% (половинный размер). Вы можете удвоить размер спрайта, установив
его масштабные значения равны 2, например:

```js
cat.scale.x = 2;
cat.scale.y = 2;
```

У Pixi есть альтернативный, краткий способ установки масштаба спрайта за один
строка кода с использованием метода `scale.set`.

```js
cat.scale.set(0.5, 0.5);
```

Если вам это нравится, используйте это!

<a id='rotation'></a>
Rotation
--------

Вы можете заставить спрайт вращаться, установив для его свойства «rotation» значение
 в [радианах](http://www.mathsisfun.com/geometry/radians.html).

```js
cat.rotation = 0.5;
```
Но вокруг какой точки происходит это вращение?

Вы видели, что верхний левый угол спрайта представляет его положение `x` и `y`. Эта точка
называется **anchor point**. Если вы установите для спрайта свойство `rotation`
в значение  `0.5`, вращение произойдет *вокруг sprite’s anchor point*.
Эта диаграмма показывает, как это повлияет на наш спрайт кошки.

![Поворот вокруг точки привязки - диаграмма](/examples/images/screenshots/07.png)

Вы можете видеть, что точка привязки, левое ухо кошки, является центром воображаемого круга, вокруг которого вращается кошка.
Что, если вы хотите, чтобы спрайт вращался вокруг своего центра? Изменить
точкe привязки спрайта так, чтобы она располагалась по центру внутри спрайта, например
так:

```js
cat.anchor.x = 0.5;
cat.anchor.y = 0.5;
```

Значения `anchor.x` и `anchor.y` представляют процент размеров текстуры от 0 до 1 (0%
до 100%). Если установить значение 0,5, текстура будет центрирована над точкой. Расположение точки
само по себе не изменится, просто то, как текстура расположена поверх него.

Следующая диаграмма показывает, что происходит с повернутым спрайтом, 
если вы центрируете его точку привязки.

![Поворот вокруг центральной точки привязки - диаграмма](/examples/images/screenshots/08.png)

Вы можете видеть, что текстура спрайта смещается вверх и влево. Эта
это важный побочный эффект, о котором следует помнить!

Как и в случае с `position` и `scale`, вы можете установить `x` и
`y` значения одной строкой кода, например:

```js
cat.anchor.set(x, y)
```

Спрайты также имеют свойство `pivot`, которое работает аналогично
Якорю. `pivot` устанавливает позицию исходной точки `x` / `y` спрайта. 
Если вы измените точку поворота, а затем повернёте спрайт, он будет
повернуть вокруг этой исходной точки.
Например, следующий код установит для точки спрайта pivot.x значение 32,
а его pivot.y указывает на 32

```js
cat.pivot.set(32, 32)
```

Предполагая, что размер спрайта составляет 64x64 пикселя, он теперь будет вращаться.
вокруг его центральной точки. Но помните: если вы измените точку поворота спрайта,
вы также изменили его исходную точку `x` / `y`.

Итак, в чем разница между `anchor` и `pivot`? Они действительно
аналогичны! `anchor` сдвигает исходную точку текстуры изображения спрайта,
используя нормализованное значение от 0 до 1.
`pivot` сдвигает начало координат `x` и `y` спрайта, используя значение пиксель.
 Что вам следует использовать? Решать вам. Просто поиграйте
с обоими и посмотрите, что вам больше нравится.

<a id='tileset'></a>
Создание спрайта из фрагмента тайлсета
--------------------------------------

Теперь вы знаете, как создать спрайт из одного файла изображения.
Но как гейм-дизайнер вы обычно будете создавать свои спрайты, используя
**tilesets** (также известен как **spritesheets**.)
В Pixi есть несколько удобных встроенных способов, которые помогут вам в этом.
Набор плиток - это отдельный файл изображения, который содержит фрагменты изображения.
Дополнительные изображения представляют собой всю графику, которую вы хотите использовать в своей игре. 
Вот пример изображения тайлсета, которое содержит игровых персонажей и игровые
объекты как суб-изображения.

![Пример набора тайлов](/examples/images/screenshots/09.png)

Размер всего тайлсета 192 на 192 пикселя. Каждое изображение - свое 32 на 32.
ячейка пиксельной сетки. Хранение и доступ ко всей игровой графике на
набор плиток очень эффективен для процессора и памяти эффективно работают с графикой, а Pixi
оптимизирован для этого.

Вы можете захватить фрагмент изображения из набора плиток, определив прямоугольную
область того же размера и положения, что и дополнительное изображение, которое вы хотите
извлекать. Вот пример фрагмента изображения ракеты, извлеченного из
набор плиток.

![Ракета извлечена из тайлсета](/examples/images/screenshots/10.png)

Давайте посмотрим на код, который это делает. Сначала загрузите изображение `tileset.png`
с Pixi `loader`, так же, как вы это делали в предыдущих примерах.

```js
loader
  .add("images/tileset.png")
  .load(setup);
```

Затем, когда изображение загружено, используйте прямоугольную подсекцию набора тайлов, чтобы создать
изображение спрайта. Вот код, который извлекает дополнительное изображение, создает
спрайт ракеты, а также позиционирует и отображает его на холсте.

```js
function setup() {

  //Создайте спрайт `tileset` из текстуры
  let texture = TextureCache["images/tileset.png"];

  //Создайте прямоугольный объект, который определяет положение и размер фрагмента изображения, которое вы хотите извлечь из текстуры.
  //(`Rectangle` это псевдоним для `PIXI.Rectangle`)
  let rectangle = new Rectangle(192, 128, 64, 64);

  //Скажите текстуре использовать эту прямоугольную секцию
  texture.frame = rectangle;

  //Создайте спрайт из текстуры
  let rocket = new Sprite(texture);

  //Поместите спрайт ракеты на холст.
  rocket.x = 32;
  rocket.y = 32;

  //Добавьте ракету на сцену
  app.stage.addChild(rocket);
  
  //Рендеринг сцены
  app.renderer.render(app.stage);
}
```

Как это работает?

Pixi имеет встроенный объект `Rectangle` (`PIXI.Rectangle`) это универсальный
объект для определения прямоугольных форм. Требуется четыре аргумента.
Первые два аргумента определяют положение прямоугольника `x` и `y`. 
Последние два определяют его ширину и высоту. Вот формат
для определения нового объекта Rectangle.

```js
let rectangle = new PIXI.Rectangle(x, y, width, height);
```

Объект прямоугольника - это просто *объект данных*; Вам решать, как вы хотите его использовать. В
в нашем примере мы используем его, чтобы определить положение и площадь
вложенное изображение на тайлсете, которое мы хотим извлечь.
Pixi textures имеют полезное свойство, называемое `frame`
который может быть установлен на любой `Rectangle` objects.
`frame` кадрирует текстуру к размеру `Rectangle`.
Вот как использовать `frame` обрезать текстуру по размеру и положению ракеты.

```js
let rectangle = new Rectangle(192, 128, 64, 64);
texture.frame = rectangle;
```

Затем вы можете использовать эту обрезанную текстуру для создания спрайта.:

```js
let rocket = new Sprite(texture);
```

Вот как это работает!

Поскольку создание текстур спрайтов из набора тайлов
то, что вы будете делать с большой частотой, Pixi предлагает более удобный способ
чтобы помочь вам в этом - давайте узнаем, что это будет дальше.

<a id='textureatlas'></a>
Использование атласа текстур
----------------------------

Если вы работаете над большой сложной игрой, вам понадобится быстрая и
эффективный способ создания спрайтов из наборов тайлов. Вот где
**texture atlas** становится действительно полезным.
Атлас текстур - это JSON файл данных, который содержит положения
и размеры фрагментов изображений на набор элементов мозаики PNG фото.
Если вы используете атлас текстур, все, что вам нужно знать о суб-изображении
вы хотите отобразить его имя.
Вы можете расположить изображения тайлсета в любом порядке, а Файл JSON
будет отслеживать их размеры и положение для вас. Это
действительно удобно, потому что это означает размеры и положение
изображения набора плиток жестко не запрограммированы в вашей игровой программе.
Если вы вносите изменения в набор элементов мозаичного изображения, например добавляете изображения, изменяете их размер,
или удалив их, просто повторно опубликуйте файл JSON, и ваша игра будет
использовать эти данные для отображения правильных изображений. Вам не нужно
вносить какие-либо изменения в код игры.

Pixi совместим со стандартным форматом атласа текстур JSON, который
вывод популярным программным инструментом под названием
[Texture Packer](https://www.codeandweb.com/texturepacker). Texture Packer’s
Лицензия Essential бесплатна. Давайте узнаем, как с его помощью
создать текстурный атлас и загрузить атлас в Pixi. (Вам не нужно использовать
Texture Packer. Подобные инструменты, например [Shoebox](http://renderhjs.net/shoebox/) или [spritesheet.js](https://github.com/krzysztof-o/spritesheet.js/), output PNG and JSON files
в стандартном формате, совместимом с Pixi.)

Сначала начните с набора отдельных файлов изображений, которые вы хотели бы
нравится использовать в своей игре.

![Image files](/examples/images/screenshots/11.png)

(Все изображения в этом разделе созданы Lanea Zimmerman. 
Вы можете найти больше ее работ
[here](http://opengameart.org/users/sharm).
Thanks, Lanea!)

Затем откройте Texture Packer и выберите **JSON Hash** в качестве основы
тип. Перетащите изображения в рабочее пространство Texture Packer. (Вы можете
также укажите Texture Packer в любую папку, содержащую ваши изображения.)
Он автоматически разместит изображения на одном изображении набора тайлов и даст им имена, соответствующие их исходным именам изображений.

![Image files](/examples/images/screenshots/12.png)

(Если вы используете бесплатную версию Texture Packer, установите **Algorithm** в `Basic`, 
установите **Trim mode** в `None`, а **Extrude** в `0`, задайте **Size constraints** в `Any size`
и передвиньте **PNG OptLevel** all the way влево на `0`. Это базовые настройки которые позволят вам в бесплатной версии Texture Packer создавать ваши файлы без ошибок и предупреждений.)

Закончив, кликните по кнопке **Publish**. Выберите имя файла и расположение, и сохраните файлы.
Вы получите 2 файла: PNG и JSON. В этом примере мои имена файлов
`treasureHunter.json` и `treasureHunter.png`. Чтобы облегчить себе жизнь,
просто сохраните оба файла в папке `images` вашего проекта. (файл JSON это как бы дополнительные
метаданные для файла изображения, поэтому есть смысл хранить оба файла в одной папке.)
файл JSON описывает имя, размер и положение каждого суб-изображения в тайлсете.
Вот отрывок, в котором описывается фрагмент изображения монстра-капли.

```js
"blob.png":
{
	"frame": {"x":55,"y":2,"w":32,"h":24},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":24},
	"sourceSize": {"w":32,"h":24},
	"pivot": {"x":0.5,"y":0.5}
},
```

Файл `treasureHunter.json` файл также содержит свойства “dungeon.png”,
“door.png”, "exit.png", и "explorer.png" свойства, каждый с
подобными данными. Каждое из этих изображений называется **frames**.
Эти данные действительно полезны, потому что теперь вам не нужно знать
размер и положение каждого фрагмента изображения в тайлсете. Все что вам нужно
знать, это спрайт **frame id**. Идентификатор кадра - это просто имя
исходного файла изображения, например "blob.png" или "explorer.png".

Среди множества преимуществ использования текстурного атласа можно отметить:
легко добавить 2 пикселя отступа вокруг каждого изображения (Texture Packer делает
это по умолчанию.) Это важно для предотвращения возможности
**texture bleed**. Texture bleed это эффект, который происходит, когда
край соседнего изображения на тайлсете появляется рядом со спрайтом.
Это происходит из-за того, как графический процессор вашего компьютера (Graphics
Processing Unit) решает, как округлить значения дробных пикселей. Должен
это округлить их вверх или вниз? Это будет отличаться для каждого графического процессора.
Если оставить интервал в 1 или 2 пикселя вокруг изображений на тилсете, все
изображения отображаются последовательно.

(Note: Если у вас есть два пикселя отступа вокруг изображения, но вы по-прежнему замечаете странный сбой «смещение на один пиксель» в способе отображения Pixi, попробуйте изменить алгоритм режима масштабирования текстуры.
Here's how: `texture.baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;`.
Эти сбои иногда могут возникать из-за ошибок округления чисел с плавающей запятой графического процессора.)

Теперь, когда вы знаете, как создать атлас текстур, давайте узнаем, как
загрузите это в свой игровой код.

<a id='loadingatlas'></a>
Загрузка атласа текстур
-----------------------

Чтобы получить атлас текстур в Pixi, загрузите его с помощью Pixi
`loader`. Если файл JSON был создан с Texture Packer, 
`loader` интерпретирует данные и создаст текстуру из каждого
кадра на тайлсете автоматически.  Вот как использовать `loader`
для загрузки файла `treasureHunter.json` .
Когда он загрузился, функция `setup` будет запущена.

```js
loader
  .add("images/treasureHunter.json")
  .load(setup);
```

Каждое изображение на тайлсете теперь представляет собой отдельную
текстуру в кэше Pixi.
Вы можете получить доступ к каждой текстуре в кеше с тем же именем,
что у нее было в Texture Packer (“blob.png”, “dungeon.png”, “explorer.png”,
etc.).

<a id='creatingsprites'></a>
Создание спрайтов из загруженного атласа текстур
--------------------------------------------

Pixi предлагает три основных способа создания спрайта из текстурного атласа.:

1. ИСпользуя `TextureCache`:

```js
let texture = TextureCache["frameId.png"],
    sprite = new Sprite(texture);
```

2. Если вы использовали Pixi `loader` чтобы загрузить атлас текстур, используйте загрузчик `resources`:

```js
let sprite = new Sprite(
  resources["images/treasureHunter.json"].textures["frameId.png"]
);
```

1. Это слишком много для создания спрайта!
Поэтому я предлагаю вам создать псевдоним под названием `id`
который указывает на текстуры объект `textures` атласа текстур, вот так:

```js
let id = PIXI.loader.resources["images/treasureHunter.json"].textures; 
```

Затем вы можете просто создавать каждый новый спрайт следующим образом:

```js
let sprite = new Sprite(id["frameId.png"]);
```

Намного лучше!

Вот как вы можете использовать эти три разных способа создания спрайтов
в функции `setup` для создавания и отображения спрайтов
 `dungeon`, `explorer`, и `treasure`.

```js

//Определите переменные, которые могут использоваться более чем в одной функции
let dungeon, explorer, treasure, id;

function setup() {

  // Есть 3 способа сделать спрайты из текстурных кадров атласа

  // 1. Access the `TextureCache` directly
  let dungeonTexture = TextureCache["dungeon.png"];
  dungeon = new Sprite(dungeonTexture);
  app.stage.addChild(dungeon);

  // 2. Доступ к текстуре с помощью загрузчика `resources`:
  explorer = new Sprite(
    resources["images/treasureHunter.json"].textures["explorer.png"]
  );
  explorer.x = 68;

  // Центрировать проводник по вертикали
  explorer.y = app.stage.height / 2 - explorer.height / 2;
  app.stage.addChild(explorer);

  // 3. Создайте дополнительный псевдоним с именем `id` для всех текстур
  // идентификаторов кадров атласа текстур.
  id = PIXI.loader.resources["images/treasureHunter.json"].textures;
  
  // Создание сундука сокровищ с помощью псевдонима
  treasure = new Sprite(id["treasure.png"]);
  app.stage.addChild(treasure);

  // Расположите сокровище рядом с правым краем холста.
  treasure.x = app.stage.width - treasure.width - 48;
  treasure.y = app.stage.height / 2 - treasure.height / 2;
  app.stage.addChild(treasure);
}
```

Вот что отображает этот код:

![Исследователь, темница и сокровища](/examples/images/screenshots/13.png)

Размеры сцены составляют 512 на 512 пикселей, и вы можете увидеть в
коде выше, что свойства `app.stage.height` и `app.stage.width` используют
для выравнивания спрайтов. Вот как `y` положение у `explorer` центрируется вертикально:

```js
explorer.y = app.stage.height / 2 - explorer.height / 2;
```

Научиться создавать и отображать спрайты с помощью атласа текстур - это
важный ориентир. Итак, прежде чем мы продолжим, давайте взглянем на
код, который вы можете написать, чтобы добавить оставшиеся спрайты:
дверь `blob` и `exit`, чтобы вы могли создать сцену это выглядит так:

![Все спрайты текстурного атласа](/examples/images/screenshots/14.png)

Вот весь код, который все это делает. Я также включил HTML
код, чтобы вы могли видеть все в правильном контексте.
(Вы найдете этот рабочий код в файле `examples/spriteFromTextureAtlas.html`
в этом репозитории.)
Обратите внимание, что спрайты `blob` создаются и добавляются на сцену в
цикле и назначенны случайные позиции.

```js
<!doctype html>
<meta charset="utf-8">
<title>Делаем спрайт из текстурного атласа</title>
<body>
<script src="../pixi/pixi.min.js"></script>
<script>

//Псевдонимы
let Application = PIXI.Application,
    Container = PIXI.Container,
    loader = PIXI.loader,
    resources = PIXI.loader.resources,
    TextureCache = PIXI.utils.TextureCache,
    Sprite = PIXI.Sprite,
    Rectangle = PIXI.Rectangle;

//Создаем приложение Pixi
let app = new Application({ 
    width: 512,
    height: 512,
    antialias: true,
    transparent: false,
    resolution: 1
  }
);

// Добавьте холст, который Pixi автоматически создал для вас, в HTML-документ.
document.body.appendChild(app.view);

// загружаем файл JSON и по завершении запустить функцию `setup`
loader
  .add("images/treasureHunter.json")
  .load(setup);

// Определите переменные, которые могут использоваться более чем в одной функции
let dungeon, explorer, treasure, door, id;

function setup() {

  //Есть 3 способа сделать спрайты из текстурных кадров атласа

  //1. Доступ к кэшу `TextureCache` напрямую
  let dungeonTexture = TextureCache["dungeon.png"];
  dungeon = new Sprite(dungeonTexture);
  app.stage.addChild(dungeon);

  //2. Доступ к текстуре через загрузчик `resources`:
  explorer = new Sprite(
    resources["images/treasureHunter.json"].textures["explorer.png"]
  );
  explorer.x = 68;

  //Центрировать проводник по вертикали
  explorer.y = app.stage.height / 2 - explorer.height / 2;
  app.stage.addChild(explorer);

  //3. Создайте необязательный псевдоним с именем ʻid`
  // для всех текстур идентификатора кадра атласа текстур.
  id = PIXI.loader.resources["images/treasureHunter.json"].textures;
  
  //Сделайте сундук с сокровищами, используя псевдоним
  treasure = new Sprite(id["treasure.png"]);
  app.stage.addChild(treasure);

  //Расположите сокровище рядом с правым краем холста.
  treasure.x = app.stage.width - treasure.width - 48;
  treasure.y = app.stage.height / 2 - treasure.height / 2;
  app.stage.addChild(treasure);

  //Сделайте дверь выхода
  door = new Sprite(id["door.png"]);
  door.position.set(32, 0);
  app.stage.addChild(door);

  //Сделайте блобы
  let numberOfBlobs = 6,
      spacing = 48,
      xOffset = 150;

  //Сделайте столько блобов, сколько есть `numberOfBlobs`
  for (let i = 0; i < numberOfBlobs; i++) {

    //Делаем блобы
    let blob = new Sprite(id["blob.png"]);

    //Разместите каждый блоб(каплю) по горизонтали в соответствии со значением `spacing`.
    //`xOffset` определяет точку слева на экране, в которую должен быть добавлен первый blob.
    let x = spacing * i + xOffset;

    //Задайте для капли случайную позицию y
    //(`randomInt` это настраиваемая функция - см. ниже)
    let y = randomInt(0, app.stage.height - blob.height);

    //Установите положение капли
    blob.x = x;
    blob.y = y;

    //Добавьте спрайт капли на сцену
    app.stage.addChild(blob);
  }
}

//Вспомогательная функция `randomInt`
function randomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

</script>
</body>
```

В приведенном выше коде видно, что все капли создаются с использованием
wbrkf `for`. Каждая капла - `blob` равномерно распределен по оси `x` :

```js
let x = spacing * i + xOffset;
blob.x = x;
```

`spacing` имеет значение 48, и `xOffset` равен 150. Что
означает, что первый `blob` будет иметь позицию `x` 150.
Это смещает его от левой стороны сцены на 150 пикселей.
Каждый последующий `blob` будет иметь значение `x` на 48 пикселей больше чем
`blob` созданный на предыдущей итерации цикла.
Это создает равномерно расположенную линию из капель монстров слева направо вдоль пола подземелья.

Каждый `blob` также получает случайную позицию по `y`. 
Вот код, который это делает:

```js
let y = randomInt(0, stage.height - blob.height);
blob.y = y;
```

The `blob`'s `y` позиции может быть присвоено любое случайное число
между  0 и 512, что является значением `stage.height`.
Это работает с помощью специальной функции, называемой `randomInt`.
`randomInt` возвращает случайное число, которое находится
в диапазоне между любыми двумя заданными вами числами.

```js
randomInt(lowestNumber, highestNumber)
```

Это означает, что если вам нужно случайное число от 1 до 10, вы можете получить
его так:

```js
let randomNumber = randomInt(1, 10);
```

Вот определение функции `randomInt`, которая выполняет всю эту работу:

```js
function randomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
```

`randomInt` отличная маленькая функция, которую можно носить в заднем кармане
создание игр - я использую его все время.

<a id='movingsprites'></a>
Движение спрайтов
-----------------

Теперь вы знаете, как отображать спрайты, но как заставить их двигаться?
Это просто: создайте функцию цикла с помощью Pixi `ticker`
Это называется **game loop**.
Любой код, который вы помещаете в game loop будет обновляться 60 раз в секунду.
Вот код, который можно написать, чтобы спрайт `cat` двигался
вправо со скоростью 1 пиксель на кадр.

```js

function setup() {

  //Запустите игровой цикл, добавив функцию `gameLoop` к
  //Pixi `ticker` и предоставив ему аргумент `delta`.
  app.ticker.add(delta => gameLoop(delta));
}

function gameLoop(delta){

  //Переместите кошку на 1 pixel
  cat.x += 1;
}
```

Если вы запустите этот фрагмент кода, вы увидите, что спрайт постепенно переместится в
правую часть сцены.

![Движущиеся спрайты](/examples/images/screenshots/15.png)

Это потому, что каждый раз запуск `gameLoop`, добавляет 1 к позиции кошки по оси x.

```js
cat.x += 1;
```

Любая функция, которую вы добавляете в Pixi `ticker` будет вызываться 60 раз в секунду. Вы можете видеть, что функция имеет аргумент `delta` - что это такое?

Значение `delta` представляет собой величину дробной задержки между кадрами. При желании вы можете добавить его к положению кота, чтобы анимация кота не зависела от частоты кадров. Вот так:

```js
cat.x += 1 + delta;
```

Независимо от того, добавляете ли вы это значение `delta` или нет, это во многом эстетический выбор. И эффект будет действительно заметен только в том случае, если ваша анимация изо всех сил пытается поддерживать постоянную скорость отображения 60 кадров в секунду (что может произойти, например, если она работает на медленном устройстве). Остальные примеры в этом руководстве не будут использовать это значение `delta`, но вы можете свободно использовать его в своей работе, если хотите.

Вам не обязательно использовать тикер Pixi для создания игрового цикла. Если хотите, просто используйте `requestAnimationFrame`, например:

```js
function gameLoop() {

  //Вызовите эту функцию gameLoop при следующем обновлении экрана (что происходит 60 раз в секунду).
  requestAnimationFrame(gameLoop);

  //Перемещение кошки
  cat.x += 1;
}

//Начать цикл
gameLoop();

```

Выбор стиля зависит только от вас..

И это действительно все! Просто измените любое свойство спрайта на небольшое
увеличение внутри цикла, и со временем они будут анимироваться. Если ты хочешь
спрайт для анимации в противоположном направлении (слева), просто дайте ему
отрицательное значение, например `-1`.

Вы найдете этот код в файле `movingSprites.html` - вот полный код:

```js
//Псевдонимы
let Application = PIXI.Application,
    Container = PIXI.Container,
    loader = PIXI.loader,
    resources = PIXI.loader.resources,
    TextureCache = PIXI.utils.TextureCache,
    Sprite = PIXI.Sprite,
    Rectangle = PIXI.Rectangle;

//Создание Pixi приложения
let app = new Application({
    width: 256,
    height: 256,
    antialias: true,
    transparent: false,
    resolution: 1
  }
);

//Добавьте холст, который Pixi автоматически создал для вас, в HTML-документ.
document.body.appendChild(app.view);

loader
  .add("images/cat.png")
  .load(setup);

//Определите любые переменные, которые используются более чем в одной функции
let cat;

function setup() {

  //Create the `cat` sprite 
  cat = new Sprite(resources["images/cat.png"].texture);
  cat.y = 96;
  app.stage.addChild(cat);

  //Start the game loop
  app.ticker.add(delta => gameLoop(delta));
}

function gameLoop(delta){

  //Move the cat 1 pixel
  cat.x += 1;
  
  //Optionally use the `delta` value
  //cat.x += 1 + delta;
}
```

(Обратите внимание, что переменная `cat` необходимо определить вне функций
`setup` и `gameLoop` так, чтобы вы имели доступ из обеих функций.)

Вы можете анимировать масштаб, вращение или размер спрайта - что угодно! Ты увидишь
впереди еще много примеров того, как анимировать спрайты.

<a id='velocity'></a>
Использование скоростных свойств
--------------------------------

Для большей гибкости рекомендуется управлять скоростью передвижения спрайтов
с помощью двух **velocity properties**: `vx` и `vy`. 
`vx` используется для установки скорости и направления спрайта по оси x
(горизонтально).
`vy` используется для установки скорости и направления спрайта по оси y (по вертикали).
Вместо того, чтобы напрямую изменять значения `x` и `y` спрайта, сначала
обновите переменные скорости, а затем присвойте эти значения скорости спрайту.
Это дополнительная модульность, необходимая для интерактивной игровой анимации.

Первый шаг - создать свойства `vx` и `vy` вашему спрайту, и дайте им начальное значение.

```js
cat.vx = 0;
cat.vy = 0;
```

Установка `vx` и `vy` в 0 означает, что спрайт не движется.

Далее в game loop, обновляем `vx` и `vy` со скоростью, с которой вы
хотите, чтобы спрайт двигался. Затем присвойте эти значения
свойствам `x` и `y` спрайта. Вот как это можно использовать,
чтобы спрайт кошки двигался вниз и вправо на один пиксель каждый
кадр:

```js
function setup() {

  //создаем спрайт `cat`
  cat = new Sprite(resources["images/cat.png"].texture);
  cat.y = 96;
  cat.vx = 0;
  cat.vy = 0;
  app.stage.addChild(cat);

  //стратуем game loop
  app.ticker.add(delta => gameLoop(delta));
}

function gameLoop(delta){

  //Обновляем скорость кошки
  cat.vx = 1;
  cat.vy = 1;

  //Примените значения скорости к положению кошки, чтобы она двигалась
  cat.x += cat.vx;
  cat.y += cat.vy;
}


```

Когда вы запустите этот код, кошка переместится вниз и вправо на один
пиксель на кадр:

![Moving sprites](/examples/images/screenshots/16.png)

Что, если вы хотите заставить кошку двигаться в другом направлении? Чтобы
заставить кошку переместиться влево, дайте ей `vx` значение `-1`. 
Чтобы он двигался вверх, дайте кошке `vy` значение `-1`. 
Чтобы кошка двигалась быстрее, увеличьте значения `vx` и `vy` , например на `3`, `5`, `-2`,
или `-4`.

Далее вы увидите, как модулирование скорости спрайта с помощью `vx` и
`vy` свойств скоростей помогает системам управления для игр клавиатурой
и указателем мыши, а также упрощает реализацию физики.

<a id='gamestates'></a>
Игровые состояния
-----------

С точки зрения стиля и для модульности кода я
рекомендую структурировать игровой цикл следующим образом:

```js
//установка game state
state = play;

//старт game loop
app.ticker.add(delta => gameLoop(delta));

function gameLoop(delta){

  //обновление текущего game state:
  state(delta);
}

function play(delta) {

  //Перемещайте кота на 1 пиксель вправо на каждый кадр
  cat.vx = 1
  cat.x += cat.vx;
}
```

Вы можете видеть, что `gameLoop` вызывает функцию с именем `state` 60 раз
в секунду. Что это за функция `state` ?
Ей была назначена `play`. Это означает, что весь код в функции `play` также выполняется
60 раз в секунду.

Вот как можно преобразовать код из предыдущего примера в эту новую модель:

```js
//Определите любые переменные, которые используются более чем в одной функции
let cat, state;

function setup() {

  //Create the `cat` sprite
  cat = new Sprite(resources["images/cat.png"].texture);
  cat.y = 96;
  cat.vx = 0;
  cat.vy = 0;
  app.stage.addChild(cat);

  //Set the game state
  state = play;

  //Start the game loop
  app.ticker.add(delta => gameLoop(delta));
}

function gameLoop(delta){

  //Update the current game state:
  state(delta);
}

function play(delta) {

  //Move the cat 1 pixel to the right each frame
  cat.vx = 1
  cat.x += cat.vx;
}
```

Да, я знаю, это немного [головоломно](http://www.amazon.com/Electric-Psychedelic-Sitar-Headswirlers-1-5/dp/B004HZ14VS)! Но пусть это не пугает вас и потратьте минуту или две, размышляя над тем, как
функции связаны.
Как вы увидите дальше, структурируя ваши игры
такой цикл значительно упростит выполнение таких операций, как переключение
игровых сцен и уровней.

<a id='keyboard'></a>
движения клавиатурой
--------------------

Приложив немного больше усилий, вы сможете создать простую систему управления
спрайтом с помощью клавиатуры. Чтобы упростить ваш код, я предлагаю вам использовать
эту настраиваемую функцию называемую `keyboard` который слушает и улавливает
события клавиатуры.

```js
function keyboard(value) {
  let key = {};
  key.value = value;
  key.isDown = false;
  key.isUp = true;
  key.press = undefined;
  key.release = undefined;
  // `downHandler`
  key.downHandler = event => {
    if (event.key === key.value) {
      if (key.isUp && key.press) key.press();
      key.isDown = true;
      key.isUp = false;
      event.preventDefault();
    }
  };

  // `upHandler`
  key.upHandler = event => {
    if (event.key === key.value) {
      if (key.isDown && key.release) key.release();
      key.isDown = false;
      key.isUp = true;
      event.preventDefault();
    }
  };

  //Присоединить слушателей событий
  const downListener = key.downHandler.bind(key);
  const upListener = key.upHandler.bind(key);
  
  window.addEventListener(
    "keydown", downListener, false
  );
  window.addEventListener(
    "keyup", upListener, false
  );
  
  // Отключить слушателей событий
  key.unsubscribe = () => {
    window.removeEventListener("keydown", downListener);
    window.removeEventListener("keyup", upListener);
  };
  
  return key;
}
```

Функция `keyboard` проста в использовании. Создайте новый объект клавиатуры, подобный этому:

```js
let keyObject = keyboard(keyValue);
```

Его единственный аргумент - это ключевое значение, которое вы хотите услышать.
[Here's a list of keys](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values).

Затем назначьте методы `press` и `release` объекту keyboard:

```js
keyObject.press = () => {
  // объект key нажатие
};
keyObject.release = () => {
  // объект key отпускание
};
```

Объекты клавиатуры также имеют булевы свойства `isDown` и `isUp`
которые можно использовать для проверки состояния каждой клавиши.

Не забудьте удалить прослушиватели событий с помощью метода `unsubscribe` :

```js
keyObject.unsubscribe();
```

Взгляните на файл `keyboardMovement.html` в папке `examples` чтобы увидеть,
как можно использовать эту функцию `keyboard` для управления спрайтом используя
клавиши со стрелками на вашей клавиатуре. Запустите его и используйте влево, вверх, вниз и вправо
клавиши со стрелками для перемещения кота по сцене.

![Keyboard movement](/examples/images/screenshots/17.png)

Вот код, который все это делает:

```js
//Определите любые переменные, которые используются более чем в одной функции
let cat, state;

function setup() {

  //Создайте спрайт `cat`
  cat = new Sprite(resources["images/cat.png"].texture);
  cat.y = 96;
  cat.vx = 0;
  cat.vy = 0;
  app.stage.addChild(cat);

  //Захватить клавиши со стрелками на клавиатуре
  let left = keyboard("ArrowLeft"),
      up = keyboard("ArrowUp"),
      right = keyboard("ArrowRight"),
      down = keyboard("ArrowDown");

  //Метод клавиша со стрелкой влево `нажата`
  left.press = () => {
    //Изменение скорости кошки при нажатии клавиши
    cat.vx = -5;
    cat.vy = 0;
  };
  
  //Клавиша со стрелкой влево `отпущена`
  left.release = () => {
    //Если стрелка влево отпущена, а стрелка вправо не нажата
    // и кошка не движется вертикально:
    //Остановить кошку
    if (!right.isDown && cat.vy === 0) {
      cat.vx = 0;
    }
  };

  //Вверх
  up.press = () => {
    cat.vy = -5;
    cat.vx = 0;
  };
  up.release = () => {
    if (!down.isDown && cat.vx === 0) {
      cat.vy = 0;
    }
  };

  //Вправо
  right.press = () => {
    cat.vx = 5;
    cat.vy = 0;
  };
  right.release = () => {
    if (!left.isDown && cat.vy === 0) {
      cat.vx = 0;
    }
  };

  //Вниз
  down.press = () => {
    cat.vy = 5;
    cat.vx = 0;
  };
  down.release = () => {
    if (!up.isDown && cat.vx === 0) {
      cat.vy = 0;
    }
  };

  //Установите состояние игры
  state = play;

  //Запустить игровой цикл
  app.ticker.add(delta => gameLoop(delta));
}

function gameLoop(delta){

  //Обновить текущий game state:
  state(delta);
}

function play(delta) {

  //Используйте скорость кошки, чтобы заставить ее двигаться
  cat.x += cat.vx;
  cat.y += cat.vy
}
```

<a id='grouping'></a>
Группировка спрайтов
--------------------

Группы позволяют создавать игровые сцены и вместе управлять похожими спрайтами
как отдельными единицами. В Pixi есть объект называемый `Container`
который позволяет вам сделать это. Давайте узнаем, как это работает.

Представьте что вы хотите отобразить три спрайта: cat, hedgehog и
tiger. Создайте их и установите их позиции *но не добавляйте их к сцене!*.

```js
//Кот
let cat = new Sprite(id["cat.png"]);
cat.position.set(16, 16);

//Ёжик
let hedgehog = new Sprite(id["hedgehog.png"]);
hedgehog.position.set(32, 32);

//Тигр
let tiger = new Sprite(id["tiger.png"]);
tiger.position.set(64, 64);
```

Теперь создайте контейнер `animals` чтобы сгрупировать их всех вместе:

```js
let animals = new PIXI.Container();
```

Затем используйте `addChild` чтобы *добавить спрайты в группу*.

```js
animals.addChild(cat);
animals.addChild(hedgehog);
animals.addChild(tiger);
```

Наконец, добавьте группу на сцену.

```js
app.stage.addChild(animals);
```

(Как известно, объект `stage` также является `Container`. 
Это корневой контейнер для всех спрайтов Pixi.)

Вот что производит этот код:

![Группировка спрайтов](/examples/images/screenshots/18.png)

То, что вы не видите на этом изображении, - это невидимая группа животных.
это содержит спрайты.

![Группировка спрайтов](/examples/images/screenshots/19.png)

Теперь вы можете использовать группу `animals` как единый юнит.
`Container` как особый вид спрайта, который не имеет текстуру.

Если вам нужен список всех дочерних спрайтов, содержащихся в `animals`,
используйте его массив `children`.

```js
console.log(animals.children)
//Отобразит: Array [Object, Object, Object]
```

Это говорит вам, что `animals` имеет три спрайта - потомка.

Поскольку группа `animals` как и любой другой спрайт, Вы можете
изменить его `x` и `y` значения, `alpha`, `scale` а также
все остальные свойства спрайта. Любое значение свойства, которое вы изменяете на
родительский контейнер будет относительным образом влиять на дочерние спрайты.
Итак, если вы установите `x` и `y` положения группы, все дочерние спрайты будут
перемещенны относительно левого верхнего угла группы.
Что произойдет, если вы установите значение `x` и `y ` группы animals в 64?

```js
animals.position.set(64, 64);
```

Вся группа спрайтов переместится на 64 пикселя вправо и на 64 пикселя вправо.
вниз.

![Группировка спрайтов](/examples/images/screenshots/20.png)

Группа `animals` также имеет свои размеры, которые основаны на площади
занятой содержащимися спрайтами. Вы можете найти его `width` и
`height` так:

```js
console.log(animals.width);
//Displays: 112

console.log(animals.height);
//Displays: 112

```

![Ширина и высота группы](/examples/images/screenshots/21.png)

Что произойдет, если вы измените ширину или высоту группы?

```js
animals.width = 200;
animals.height = 200;
```

Все дочерние спрайты будут масштабироваться в соответствии с этим изменением..

![Ширина и высота группы](/examples/images/screenshots/22.png)

Вы можете вложить столько `Container` внутрь другого
`Container` сколько вам надо, создавая глубокие иерархии, если
нужно. Но, `DisplayObject` (такой как `Sprite` или другой
`Container`) может принадлежать только одному родителю за раз.
Если вы используете `addChild` сделать спрайт дочерним по отношению
к другому объекту, Pixi автоматически удалит его из текущего родителя.
Это полезный элемент управления, о котором вам не нужно беспокоиться.

<a id='localnglobal'></a>
### Локальная и глобальная положения

Когда вы добавляете спрайт в `Container`, его `x` и `y`
положение является *относительно левого верхнего угла группы*.
Это **local position** спрайта например, как ты думаешь кошачий
позиция на этом изображении?

![Группировка спрайтовs](/examples/images/screenshots/20.png)

Давай выясним:

```js
console.log(cat.x);
//Displays: 16
```

16? Да! Это потому, что кот смещен всего на 16 пикселей от
левого верхнего угла группы. 16 - локальное положение кошки.

Спрайты также имеют **global position**. Мировая позиция - это
расстояние от верхнего левого угла сцены, к точке привязки спрайта
(обычно верхний левый угол спрайта.) Вы можете найти глобальный
положение с помощью метода `toGlobal`.
Вот как:

```js
parentSprite.toGlobal(childSprite.position)
```

Это означает, что вы можете найти глобальное положение кошки внутри ʻanimals`
группы вот так:

```js
console.log(animals.toGlobal(cat.position));
//Displays: Object {x: 80, y: 80...};
```

Это дает вам положение `x` и `y` равное 80. Это точно кошачий
глобальное положение относительно левого верхнего угла сцены.

Что делать, если вы хотите найти глобальную позицию спрайта, но не
знаете, что является родительским контейнером спрайта?
У каждого спрайта есть свойство, называемое `parent` это скажет вам, что за
родитель спрайта. Если добавить спрайт прямо в `stage`, то
`stage` будет родителем спрайта. В приведенном выше примере родитель `cat`
это `animals`. Это означает, что вы также можете получить глобальное положение кошки.
написав такой код:

```js
cat.parent.toGlobal(cat.position);
```

И он будет работать, даже если вы не знаете, что у кота родитель
контейнер в настоящее время.

Есть еще один способ рассчитать глобальную позицию! И это
на самом деле лучший способ, так что слушайте! Если вы хотите знать расстояние
от левого верхнего угла холста до спрайта, позаботьтесь о родительских контейнерах спрайта, используйте метод `getGlobalPosition`.
Вот как с его помощью найти глобальное положение тигра:

```js
tiger.getGlobalPosition().x
tiger.getGlobalPosition().y
```

Это даст вам `x` и `y` значение = 128 в примере, который мы
использовали.
Особенность в `getGlobalPosition` в том, что это очень
точно: это даст вам точное глобальное положение спрайта как
только его локальное положение изменится.
Я просил команду разработчиков Pixi добавить эту функцию
специально для точного обнаружения столкновений в игре.
(Спасибо, Мэтт и остальная часть команды за добавление!)

Что, если вы хотите преобразовать глобальную позицию в локальную? вы
можете использовать метод `toLocal`. Он работает аналогичным образом,
но использует этот общий формат:

```js
sprite.toLocal(sprite.position, anyOtherSprite)
```

Используйте `toLocal` найти расстояние между спрайтом и любым другим
спрайтом. Вот как можно узнать, где расположен тигр, относительно ежа.

```js
tiger.toLocal(tiger.position, hedgehog).x
tiger.toLocal(tiger.position, hedgehog).y
```

Это дает вам значение `x` = 32 и `y` = 32. Ты можешь видеть
в примерах изображений верхний левый угол тигра равен 32 пикселям
вниз и влево от верхнего левого угла ежика.

<a id='spritebatch'></a>
### Использование ParticleContainer для группировки спрайтов

У Pixi есть альтернативный, высокопроизводительный способ группировки спрайтов, называемый
а `ParticleContainer` (`PIXI.particles.ParticleContainer`). Любые спрайты внутри `ParticleContainer` рендерятся от 2 до 5 раз быстрее, чем если бы они были в обычном `Container`.
Это отличный прирост производительности для игр.

Создать `ParticleContainer` можно так:

```js
let superFastSprites = new PIXI.particles.ParticleContainer();
```

Затем используйте `addChild` чтобы добавить к нему спрайты, как если бы вы делали это с любым
обыкновенный `Container`.

Вы должны пойти на некоторые компромиссы, если решите использовать
`ParticleContainer`. Спрайты внутри `ParticleContainer` имеют только несколько основных свойств:
`x`, `y`, `width`, `height`, `scale`, `pivot`, `alpha`, `visible` – и это
об этом.
Кроме того, содержащиеся в нем спрайты не могут быть вложенными собственные дети.
`ParticleContainer` также не может использовать расширенные визуальные эффекты Pixi, такие как фильтры и режимы наложения. Каждый `ParticleContainer` может использовать только одну текстуру (поэтому вам придется использовать таблицу спрайтов, если вам нужны спрайты с другим внешним видом). Но для огромного прироста производительности эти компромиссы обычно того стоят.
И вы можете использовать `Container` и `ParticleContainer` одновременно в одном и том же проекте, поэтому вы можете настроить оптимизацию.

Почему спрайты в `Particle Container` такие быстрые? Потому, что позиции
спрайтов рассчитываются непосредственно на GPU. Команда разработчиков Pixi
работает на то, чтобы переложить обработку спрайтов, по возможности на GPU,
поэтому вполне вероятно, что последняя версия Pixi
которые вы используете, будут иметь гораздо больше функций `ParticleContainer` чем
то, что я описал здесь.
Проверить текущую документацию [документация `ParticleContainer`](http://pixijs.download/release/docs/PIXI.particles.ParticleContainer.html) .

При создании `ParticleContainer`, есть четыре дополнительных
аргументы, которые вы можете предоставить: `size`, `properties`, `batchSize` и `autoResize`.

```js
let superFastSprites = new ParticleContainer(maxSize, properties, batchSize, autoResize);
```

Значение по умолчанию для `maxSize` это 1500. Итак, если вам нужно содержать больше
спрайты, установите большее число. Аргумент `properties` это объект
с 5 логическими значениями: `scale`, `position`, `rotation`, `uvs` и
`alphaAndTint`. The default value of `position` is `true`, but all the others
are set to `false`. That means that if you want change the `rotation`,
`scale`, `tint`, or `uvs` of sprite in the `ParticleContainer`, you
have to set those properties to `true`, like this:

```js
let superFastSprites = new ParticleContainer(
  size,
  {
    rotation: true,
    alphaAndtint: true,
    scale: true,
    uvs: true
  }
);
```

But, if you don't think you'll need to use these properties, keep them
set to `false` to squeeze out the maximum amount of performance.

What's the `uvs` property? Only set it to `true` if you have particles
which change their textures while they're being animated. (All the
sprite's textures will also need to be on the same tileset image for
this to work.) 

(Note: **UV mapping** is a 3D graphics display term that refers to
the `x` and `y` coordinates of the texture (the image) that is being
mapped onto a 3D surface. `U` is the `x` axis and `V` is the `y` axis.
WebGL already uses `x`, `y` and `z` for 3D spatial positioning, so `U`
and `V` were chosen to represent `x` and `y` for 2D image textures.)

(I'm not sure what exactly what those last two optional arguments, `batchSize` and `autoResize`, so if anyone knows, please us know in the Issues!)

<a id='graphic'></a>

Графические примитивы Pixi
--------------------------

Использование текстур изображений - один из самых полезных способов создания спрайтов,
но у Pixi также есть свои собственные низкоуровневые инструменты рисования. Вы можете использовать их чтобы
создавать прямоугольники, формы, линии, сложные многоугольники и текст. А также,
к счастью, он использует почти тот же API, что и [Canvas Drawing API](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Drawing_graphics_with_canvas) так,
если вы уже знакомы с холстом HTML5, то для вас в этом не будет ничего нового. Но большое преимущество в том, что, в отличие от Canvas Drawing API,
  фигуры, которые вы рисуете с помощью Pixi, обрабатываются WebGL на графическом процессоре. Pixi
  позволяет получить доступ ко всей этой неиспользованной мощности.
Давайте кратко рассмотрим, как создавать основные формы. Вот все
формы, которые мы создадим в следующем коде.
![Графические примитивы](/examples/images/screenshots/23.png)

<a id='rectangles'></a>
### Прямоугольники

Все формы создаются путем создания нового экземпляра Pixi класса
`Graphics` (`PIXI.Graphics`).

```js
let rectangle = new Graphics();
```

Используйте `beginFill` с шестнадцатеричным значением цветового кода, чтобы установить
цвет заливки прямоугольника. Вот как настроить его на голубой.

```js
rectangle.beginFill(0x66CCFF);
```

Если вы хотите придать фигуре очертание, используйте метод lineStyle. Вот
как придать прямоугольнику красный контур шириной 4 пикселя с помощью ʻalpha`
значение 1.

```js
rectangle.lineStyle(4, 0xFF3300, 1);
```

Используйте метод drawRect, чтобы нарисовать прямоугольник. Его четыре аргумента
это `x`,` y`, `width` и` height`.

```js
rectangle.drawRect(x, y, width, height);
```

Используйте `endFill` когда будете готовы.

```js
rectangle.endFill();
```

Это похоже на API рисования холста! Вот весь код, который вам нужен
нарисуйте прямоугольник, измените его положение и добавьте его на сцену.

```js
let rectangle = new Graphics();
rectangle.lineStyle(4, 0xFF3300, 1);
rectangle.beginFill(0x66CCFF);
rectangle.drawRect(0, 0, 64, 64);
rectangle.endFill();
rectangle.x = 170;
rectangle.y = 170;
app.stage.addChild(rectangle);

```

Этот код создает синий прямоугольник 64 на 64 с красной рамкой в ​​координатах x и y, равных 170..

<a id='circles'></a>
### Круги

Сделайте круг методом `drawCircle`. Его три аргумента: `x`, `y` и `radius`

```js
drawCircle(x, y, radius)
```

В отличие от прямоугольников и спрайтов, положение круга по осям x и y также является его
Центральной точкой. Вот как создать круг фиолетового цвета с радиусом 32 пикселя.

```js
let circle = new Graphics();
circle.beginFill(0x9966FF);
circle.drawCircle(0, 0, 32);
circle.endFill();
circle.x = 64;
circle.y = 130;
app.stage.addChild(circle);
```

<a id='ellipses'></a>
### Эллипсы

Pixi позволяет рисовать эллипсы в качестве альтернативы Canvas Drawing API.
методом drawEllipse.

```js
drawEllipse(x, y, width, height);
```

Положение x / y определяет верхний левый угол эллипса (представьте, что
эллипс окружен невидимой прямоугольной ограничивающей рамкой -
верхний левый угол этого поля будет представлять x / y эллипса
положение якоря). Вот желтый эллипс шириной 50 пикселей и высотой 20 пикселей.

```js
let ellipse = new Graphics();
ellipse.beginFill(0xFFFF00);
ellipse.drawEllipse(0, 0, 50, 20);
ellipse.endFill();
ellipse.x = 180;
ellipse.y = 130;
app.stage.addChild(ellipse);
```

<a id='roundedrect'></a>
### Скругленный прямоугольник

Pixi также позволяет создавать прямоугольники со скругленными углами
с помощью метода drawRoundedRect.
Последний аргумент, `cornerRadius` число в пикселях, которое
определяет, на сколько нужно закруглять углы.

```js
drawRoundedRect(x, y, width, height, cornerRadius)
```

Вот как сделать прямоугольник со скругленными углами с радиусом угла 10
пикселей.

```js
let roundBox = new Graphics();
roundBox.lineStyle(4, 0x99CCFF, 1);
roundBox.beginFill(0xFF9933);
roundBox.drawRoundedRect(0, 0, 84, 36, 10)
roundBox.endFill();
roundBox.x = 48;
roundBox.y = 190;
app.stage.addChild(roundBox);
```

<a id='lines'></a>

### Lines

В приведенных выше примерах вы видели, что метод lineStyle позволяет вам
определить линию. Вы можете использовать методы `moveTo` и `lineTo` для рисования
начальной и конечной точек линии, точно так же, как вы можете с Canvas
API рисования. Вот как нарисовать белую диагональную линию шириной 4 пикселя.

```js
let line = new Graphics();
line.lineStyle(4, 0xFFFFFF, 1);
line.moveTo(0, 0);
line.lineTo(80, 50);
line.x = 32;
line.y = 32;
app.stage.addChild(line);
```

`PIXI.Graphics` объекты, такие как линии, имеют значения x и y, просто
как спрайты, поэтому вы можете разместить их в любом месте сцены после
того как вы их нарисовали.

<a id='polygons'></a>

### Polygons

Вы можете соединять линии вместе и заливать их цветами, чтобы сделать сложные
фигуры с помощью метода `drawPolygon`. Аргумент drawPolygon - это
массив путей x/y точек, которые определяют положения каждой точки на
форма.

```js
let path = [
  point1X, point1Y,
  point2X, point2Y,
  point3X, point3Y
];

graphicsObject.drawPolygon(path);
```

`drawPolygon` соединит эти три точки вместе, чтобы получилась форма.
Вот как использовать drawPolygon для соединения трех линий
сделайте красный треугольник с синей каймой. Треугольник нарисован на
положение 0,0, а затем переместился на свое место на сцене, используя его
Свойства `x` и `y`.

```js
let triangle = new Graphics();
triangle.beginFill(0x66FF33);

//Используем `drawPolygon` чтобы определить треугольник как массив путей x/y позиций

triangle.drawPolygon([
    -32, 64,             //Первая точка
    32, 64,              //Вторая точка
    0, 0                 //Третья точка
]);

//Цвет заливки формы
triangle.endFill();

//Расположите треугольник после того, как вы его нарисовали.
//Положение треугольника x/y привязано к его первой точке на пути.
triangle.x = 180;
triangle.y = 22;

app.stage.addChild(triangle);
```

<a id='text'></a>

Отображение текста
------------------

Используйте объект `Text` (` PIXI.Text`) для отображения текста в рабочей области. В простейшей форме это можно сделать так:

```js
let message = new Text("Hello Pixi!");
app.stage.addChild(message);
```

На холсте отобразятся слова «Hello, Pixi». Объекты Pixi Text наследуются от класса Sprite, поэтому они
содержат все те же свойства, как `x`,` y`, `width`,` height`,
`alpha`, и `rotation`. Расположите и измените размер текста на сцене так же, как и любой другой спрайт. 
Например, вы можете использовать `position.set`, чтобы установить положение `x` и `y` в сообщении следующим образом:

```js
message.position.set(54, 96);
```

![Отображение текста](/examples/images/screenshots/24.png)

Это даст вам основной текст без стиля. Но если вы хотите стать красивее, используйте функцию Pixi TextStyle для определения пользовательского стиля текста. Вот как:

```js
let style = new TextStyle({
  fontFamily: "Arial",
  fontSize: 36,
  fill: "white",
  stroke: '#ff3300',
  strokeThickness: 4,
  dropShadow: true,
  dropShadowColor: "#000000",
  dropShadowBlur: 4,
  dropShadowAngle: Math.PI / 6,
  dropShadowDistance: 6,
});
```

Это создает новый объект `style` содержащий все стили текста, которые вы хотели бы использовать.
Полный список всех свойств стиля, которые вы можете использовать, [смотрите здесь](http://pixijs.download/release/docs/PIXI.TextStyle.html).

Чтобы применить стиль к тексту, добавьте объект `style` в качестве второго аргумента функции `Text`, например:

```js
let message = new Text("Hello Pixi!", style);
```

![Отображение текста](/examples/images/screenshots/24.5.png)

Если вы хотите изменить содержимое текстового объекта после того, как
создал его, используйте свойство `text`.

```js
message.text = "Text changed!";
```

Используйте свойство `style`, если вы хотите переопределить свойства стиля.

```js
message.style = {fill: "black", font: "16px PetMe64"};
```

Pixi создает текстовые объекты, используя Canvas Drawing API для
визуализациии текста на невидимом и временном элементе холста.
Затем он превращает холст в текстуру WebGL, чтобы он
можно отобразить на спрайт.
Вот почему цвет текста должен быть
завернутый в строку: это значение цвета Canvas Drawing API. Как и с
любыми значениями цвета холста, вы можете использовать слова для обозначения общих цветов, например
«Красный» или «зеленый», либо используйте значения rgba, hsla или шестнадцатеричные значения.

Pixi также может переносить длинные строки текста. Установите стиль текста wordWrap
для свойства true, а затем установите для wordWrapWidth максимальную длину.
в пикселях, что должна быть строка текста. Используйте свойство ʻalign`
для установки выравнивания для многострочного текста.

```js
message.style = {wordWrap: true, wordWrapWidth: 100, align: center};
```

(Note: `align` doesn't affect single line text.)

If you want to use a custom font file, use the CSS `@font-face` rule
to link the font file to the HTML page where your Pixi application is
running.

```js
@font-face {
  font-family: "fontFamilyName";
  src: url("fonts/fontFile.ttf");
}
```

Add this `@font-face` rule to your HTML page's CSS style sheet.

[Pixi also has support for bitmap
fonts](http://pixijs.download/release/docs/PIXI.extras.BitmapText.html). You
can use Pixi's loader to load Bitmap font XML files, the same way you
load JSON or image files.

<a id='collision'></a>
Обнаружение столкновений
------------------------

Теперь вы знаете, как создавать огромное количество разнообразных графических объектов, но какие
ты можешь с ними делать? Самое интересное - построить простую систему **collision detection**.
Вы можете использовать настраиваемую функцию под названием `hitTestRectangle` это проверяет,
соприкасаются ли какие-либо два прямоугольных спрайта Pixi.

```js
hitTestRectangle(spriteOne, spriteTwo)
```

если они перекрываются, `hitTestRectangle` вернусь `true`. Вы можете использовать `hitTestRectangle` с оператор `if` для проверки столкновения двух таких спрайтов:

```js
if (hitTestRectangle(cat, box)) {
  //Есть столкновение
} else {
  //Нет столкновения
}
```

Как вы увидите, `hitTestRectangle` вход в огромную вселенную игрового дизайна.

Запустите файл `collisionDetection.html` в папке `examples`, для
рабочего примера использования `hitTestRectangle`. Используйте клавиши со стрелками
чтобы переместить кошку. Если кошка попадает в коробку, коробка становится красной.
и "Хит!" отображается текстовым объектом.

![Отображение текста](/examples/images/screenshots/25.png)

Вы уже видели весь код, который создает все эти элементы, например
а также система управления клавиатурой, которая заставляет кошку двигаться.
Единственное новое - это путь `hitTestRectangle` используется внутри функции `play`
для проверки на столкновение.

```js
function play(delta) {

  //использовать скорость кошки, чтобы заставить ее двигаться
  cat.x += cat.vx;
  cat.y += cat.vy;

  //проверить на столкновение между кошкой и ящиком
  if (hitTestRectangle(cat, box)) {

    //при столкновении измените текст сообщения и закрасьте поле красным
    message.text = "hit!";
    box.tint = 0xff3300;

  } else {

    //если нет коллизии, сбросить текст сообщения и цвет окна
    message.text = "No collision...";
    box.tint = 0xccff99;
  }
}
```

Поскольку функция play вызывается игровым циклом 60 раз
в секунду этот оператор `if` постоянно проверяет наличие столкновения
между кошкой и коробкой. Если `hitTestRectangle` имеет значение `true`,
Объект text `message` использует `text` для отображения "Hit":

```js
message.text = "Hit!";
```

Затем цвет рамки меняется с зеленого на красный, устанавливая
box значение свойства `tint` к шестнадцатеричному значению красного цвета.

```js
box.tint = 0xff3300;
```

Если коллизий нет, сообщение и окно остаются в своих
исходные состояния:

```js
message.text = "No collision...";
box.tint = 0xccff99;
```

Этот код довольно прост, но внезапно вы создали интерактивный
мир, который кажется полностью живым. Это почти похоже на волшебство! И, возможно
как ни странно, теперь у вас есть все навыки, необходимые, чтобы начать делать
игры с Pixi!

<a id='hittest'></a>
### Функция hitTestRectangle

Но как насчет функции `hitTestRectangle`? Что он делает, и
как это работает? Подробности того, как алгоритмы обнаружения столкновений
как эта работа немного выходит за рамки этого урока.
(Если вы действительно хотите знать, вы можете узнать, как в [этой книге](https://www.apress.com/us/book/9781430258001).)
Самое главное, чтобы вы знали, как им пользоваться. Но только для
ваш отзыв, и если вам интересно, вот полное определение функции `hitTestRectangle`.
Вы можете понять из комментариев, что она делает?

```js
function hitTestRectangle(r1, r2) {

  //Определите переменные, которые нам понадобятся для расчета
  let hit, combinedHalfWidths, combinedHalfHeights, vx, vy;

  //попадание определит, есть ли столкновение
  hit = false;

  //Найдите центральные точки каждого спрайта
  r1.centerX = r1.x + r1.width / 2;
  r1.centerY = r1.y + r1.height / 2;
  r2.centerX = r2.x + r2.width / 2;
  r2.centerY = r2.y + r2.height / 2;

  //Найдите полуширину и половину высоты каждого спрайта
  r1.halfWidth = r1.width / 2;
  r1.halfHeight = r1.height / 2;
  r2.halfWidth = r2.width / 2;
  r2.halfHeight = r2.height / 2;

  //Вычислить вектор расстояния между спрайтами
  vx = r1.centerX - r2.centerX;
  vy = r1.centerY - r2.centerY;

  //Определите комбинированные полуширины и полувысоты
  combinedHalfWidths = r1.halfWidth + r2.halfWidth;
  combinedHalfHeights = r1.halfHeight + r2.halfHeight;

  //Проверить наличие столкновения по оси x
  if (Math.abs(vx) < combinedHalfWidths) {

    //Может произойти столкновение. Проверьте наличие столкновения по оси Y
    if (Math.abs(vy) < combinedHalfHeights) {

      //Определенно происходит столкновение
      hit = true;
    } else {

      //На оси Y нет столкновения
      hit = false;
    }
  } else {

    //На оси x столкновения нет
    hit = false;
  }

  //`hit` будет либо `true` либо `false`
  return hit;
};

```

<a id='casestudy'></a>
Пример использования: Treasure Hunter
-------------------------------------

Я сказал вам, что теперь у вас есть все навыки, необходимые для начала
создание игр. Какой? Вы мне не верите? Позвольте мне доказать вам это! Давайте возьмем
закрыть, как сделать простую коллекцию объектов и врага
игра избегания называется **Treasure Hunter**. (You'll find it in the `examples`
folder.)

![Treasure Hunter](/examples/images/screenshots/26.png)

Treasure Hunter - хороший пример одного из самых простых полноценных
игр, которые вы можете создавать, используя уже изученные инструменты.
Использовать кнопки со стрелками на клавиатуре, чтобы помочь исследователю
найти клад и отнести его к выходу.
Шесть монстров-капель перемещаются между стенами подземелья, и если
они попадают в исследователя, он становится полупрозрачным, а индикатор здоровья
в правом верхнем углу сжимается.
Если все здоровье израсходовано, «Ты Погиб!" отображается на сцене;
если исследователь достигает выхода с сокровище "Вы выиграли!" отображается. Хотя это базовый
прототип, Treasure Hunter содержит большинство элементов, которые вы найдете
в гораздо более крупных играх: графика текстурного атласа, интерактивность,
столкновение и несколько игровых сцен. Давайте посмотрим, как
game была составлена ​​так, чтобы вы могли использовать ее в качестве отправной точки для одной из ваших собственных игр.

### Структура кода

Откройте файл `treasureHunter.html`, и вы увидите, что вся игра
код находится в одном большом файле. 
Вот как выглядит весь код с высоты птичьего полета.
организовано.

```js
//Настройте Pixi и загрузите файлы текстурного атласа - вызовите функцию `setup` когда они загрузились

function setup() {
  //Инициализируем игровые спрайты, установите состояние игры на `play`
  //и запустите `gameLoop`
}

function gameLoop(delta) {
  //Запускаем текущий игровой `state` в loop и рендерим спрайты
}

function play(delta) {
  //Здесь происходит вся логика игры
}

function end() {
  //Весь код, который должен запускаться в конце игры
}

//Вспомогательные функции игры:
//`keyboard`, `hitTestRectangle`, `contain` и `randomInt`
```

Используйте это как карту мира в игре, поскольку мы рассмотрим,
как работает каждая секция.

<a id='initialize'></a>
### Инициализация игры в функции setup

Как только изображения атласа текстур загружены, запускается функция `setup`.
Она запускается только один раз и позволяет вам выполнять
одноразовые задания по настройке вашей игры.
Это отличное место для создания и инициализации объектов, спрайтов, игровых сцен,
заполнение массивов данных или анализа загруженых данных игры в формате JSON.

Вот сокращенный вид функции `setup` в Treasure Hunter,
и задачи, которые он выполняет.

```js
function setup() {
  //Create the `gameScene` group
  //Create the `door` sprite
  //Create the `player` sprite
  //Create the `treasure` sprite
  //Make the enemies
  //Create the health bar
  //Add some text for the game over message
  //Create a `gameOverScene` group
  //Assign the player's keyboard controllers

  //set the game state to `play`
  state = play;

  //Start the game loop 
  app.ticker.add(delta => gameLoop(delta));
}

```

Tон последние две строки кода, `state = play;` и `gameLoop()` возможно
самое важное. Добавление `gameLoop` в тикер Pixi включает движок игры.,
и вызывает функцию `play` в непрерывном цикле. Но прежде чем мы посмотрим,
как это работает, давайте посмотрим, что делает специальный код внутри функции `setup` .

<a id='gamescene'></a>
#### Создание игровых сцен

Функция `setup` создает две группы `Container`, называемые
`gameScene` и `gameOverScene`. Каждый из них добавляется на сцену.

```js
gameScene = new Container();
app.stage.addChild(gameScene);

gameOverScene = new Container();
app.stage.addChild(gameOverScene);

```

Все спрайты, которые являются частью основной игры, добавляются в
группа `gameScene`. Текст game over который должен отображаться в
конец игры добавлен в группу `gameOverScene`.

![Отображение текста](/examples/images/screenshots/27.png)

Хотя он создается в функции `setup`, `gameOverScene`
не должен быть виден при первом запуске игры, его `visible`
свойство инициализируется значением `false`.

```js
gameOverScene.visible = false;
```

Вы увидите его, когда игра закончится, свойство `gameOverScene` - `visible`
будет установлено на `true` для отображения текста, который появляется в
конец игры.

<a id='makingdungon'></a>
#### Изготовление темницы, двери, исследователя и сокровища

Игрок, выходная дверь, сундук с сокровищами и темница фоновое изображение
все спрайты сделаны из фреймов текстурного атласа. Очень важно,
все они добавлены как дети `gameScene`.

```js
//Создайте псевдоним для идентификаторов кадров атласа текстур
id = resources["images/treasureHunter.json"].textures;

//Dungeon
dungeon = new Sprite(id["dungeon.png"]);
gameScene.addChild(dungeon);

//Door
door = new Sprite(id["door.png"]);
door.position.set(32, 0);
gameScene.addChild(door);

//Explorer
explorer = new Sprite(id["explorer.png"]);
explorer.x = 68;
explorer.y = gameScene.height / 2 - explorer.height / 2;
explorer.vx = 0;
explorer.vy = 0;
gameScene.addChild(explorer);

//Treasure
treasure = new Sprite(id["treasure.png"]);
treasure.x = gameScene.width - treasure.width - 48;
treasure.y = gameScene.height / 2 - treasure.height / 2;
gameScene.addChild(treasure);
```

Сохраняя их вместе в группе `gameScene` облегчит
нам скрытие `gameScene` и отображение `gameOverScene` когда игра закончена.

<a id='makingblob'></a>
#### Создание монстров - капель (blob monsters)

Шесть монстров-капель созданы в цикле. Каждому BLOB-объекту дается
случайное начальное положение и скорость. Вертикальная скорость
поочередно умножается на `1` или `-1` для каждой капли, и вот что
заставляет каждую каплю двигаться в направлении, противоположном тому,
что находится рядом с ним. Каждый созданный монстр blob помещается в массив с именем
`blobs`.

```js
let numberOfBlobs = 6,
    spacing = 48,
    xOffset = 150,
    speed = 2,
    direction = 1;

//Массив для хранения всех монстров-капель
blobs = [];

//Сделайте столько капель, сколько есть `numberOfBlobs`
for (let i = 0; i < numberOfBlobs; i++) {

  //Сделать каплю
  let blob = new Sprite(id["blob.png"]);

  //Разместите каждую каплю по горизонтали в соответствии со значением `spacing`.
  //`xOffset` определяет точку слева на экране, в которую должен быть добавлен первый blob
  let x = spacing * i + xOffset;

  //Дайте капле случайную `y` позицию
  let y = randomInt(0, stage.height - blob.height);

  //Установите положение капли
  blob.x = x;
  blob.y = y;

  //Установите вертикальную скорость капли. direction будет либо 1, либо
  //`-1`. `1` означает, что враг пойдет вниз и `-1` означает, что капля будет
  //двигаться вверх. Умножение `direction` на `speed` определяет вертикальное
  // направление капли
  blob.vy = speed * direction;

  //Изменить направление следующей капли
  direction *= -1;

  //Поместите blob в массив `blobs`
  blobs.push(blob);

  //Добавьте каплю в `gameScene`
  gameScene.addChild(blob);
}

```

<a id='healthbar'></a>
#### Делаем полоску здоровья

Когда вы играете в «Охотник за сокровищами», вы заметите, что когда исследователь касается
один из врагов, ширина шкалы здоровья вверху справа
угол экрана уменьшается. Как была сделана эта полоска здоровья? Это
всего два перекрывающихся прямоугольника в одной и той же позиции: черный прямоугольник сзади, и
красный прямоугольник спереди. Они сгруппированы в одну группу `healthBar`.
`healthBar` затем добавляется к `gameScene` и позиционируется на сцене.

```js
//Создайте полосу здоровья
healthBar = new PIXI.Container();
healthBar.position.set(stage.width - 170, 4)
gameScene.addChild(healthBar);

//Создайте прямоугольник на черном фоне
let innerBar = new PIXI.Graphics();
innerBar.beginFill(0x000000);
innerBar.drawRect(0, 0, 128, 8);
innerBar.endFill();
healthBar.addChild(innerBar);

//Создайте передний красный прямоугольник
let outerBar = new PIXI.Graphics();
outerBar.beginFill(0xFF3300);
outerBar.drawRect(0, 0, 128, 8);
outerBar.endFill();
healthBar.addChild(outerBar);

healthBar.outer = outerBar;
```

Вы можете видеть, что свойство под названием `outer` был добавлен в
`healthBar`. Он просто ссылается на `outerBar` (красный прямоугольник)
so что потом будет удобно получить доступ.

```js
healthBar.outer = outerBar;
```

Вам не нужно этого делать; но, эй, почему бы и нет! Значит, если хочешь
контролировать ширину красного `outerBar`, вы можете написать гладкий код, который выглядит так:

```js
healthBar.outer.width = 30;
```

Это довольно аккуратно и удобно для чтения, так что мы сохраним его!

<a id='message'></a>
#### Создание текста сообщения

Когда игра закончится, появится текст «Вы выиграли!» или ты
проиграл! », в зависимости от исхода игры. Это сделано с помощью
текстовый спрайт и добавив его в `gameOverScene`. Поскольку свойство
`visible` контейнера `gameOverScene` установлено в `false` при старте игры,
вы не видите этот текст. Вот код из функции `setup` который создает
текст сообщения и добавляет его в `gameOverScene`.

```js
let style = new TextStyle({
    fontFamily: "Futura",
    fontSize: 64,
    fill: "white"
  });
message = new Text("The End!", style);
message.x = 120;
message.y = app.stage.height / 2 - 32;
gameOverScene.addChild(message);
```

<a id='playing'></a>
### Играем в игру

Вся логика игры и код, который заставляет спрайты двигаться, происходят
внутри функции `play`, который работает в непрерывном цикле. Вот
обзор того, что делает функция `play`.

```js
function play(delta) {
  //Переместите исследователя и удерживайте его внутри подземелья
  //Переместите монстров-капель
  //Проверьте наличие столкновения между каплями и проводником
  //Проверьте, нет ли столкновения между исследователем и сокровищем
  //Проверьте, нет ли столкновения между сокровищем и дверью
  //Решите, выиграна игра или проиграна
  //Измените состояние игры на ʻend`, когда игра закончится
}
```

Давайте узнаем, как работают все эти функции.

<a id='movingexplorer'></a>
### Перемещение исследователя

Проводник управляется с клавиатуры, а код,
это очень похоже на код управления клавиатурой, который вы узнали ранее.
Объекты `keyboard` изменяют скорость проводника, и это
скорость добавляется к позиции исследователя внутри `play`
функция.

```js
explorer.x += explorer.vx;
explorer.y += explorer.vy;
```

<a id='containingmovement'></a>
#### Сдерживание движения

Но что нового, так это то, что движение исследователя заключено в стенах
подземелье. Зеленый контур показывает пределы возможностей исследователя.
движение.

![Отображение текста](/examples/images/screenshots/28.png)

Это делается с помощью специальной функции, называемой
`contain`.

```js
contain(explorer, {x: 28, y: 10, width: 488, height: 480});
```

`contain` принимает два аргумента. Первый - это спрайт, который вы хотите сохранить
содержится. Второй - любой объект со свойствами `x`, `y`, `width` и
`height` которые определяют прямоугольную область. В этом примере
содержащий объект определяет область, которая немного смещена
от сцены и меньше ее. Он соответствует размерам темницы
стены.

Вот функция `contain`, которая выполняет всю эту работу. Функция проверяет
чтобы увидеть, пересек ли спрайт границы содержащего
объект. Если да, код перемещает спрайт обратно в эту границу.
Функция `contain` также возвращает переменную `collision` с
значение "сверху", "справа", "снизу" или "слева", в зависимости от того, с какой стороны
граница, на которую попал спрайт. (`collision` будет `undefined` если
спрайт не попал ни в одну из границ.)

```js
function contain(sprite, container) {

  let collision = undefined;

  //Left
  if (sprite.x < container.x) {
    sprite.x = container.x;
    collision = "left";
  }

  //Top
  if (sprite.y < container.y) {
    sprite.y = container.y;
    collision = "top";
  }

  //Right
  if (sprite.x + sprite.width > container.width) {
    sprite.x = container.width - sprite.width;
    collision = "right";
  }

  //Bottom
  if (sprite.y + sprite.height > container.height) {
    sprite.y = container.height - sprite.height;
    collision = "bottom";
  }

  //Return the `collision` value
  return collision;
}
```

Вы увидите, как в коде будет использоваться возвращаемое значение `collision`.
впереди, чтобы монстры-капли подпрыгивали между вершинами
и нижние стены подземелья.

<a id='movingmonsters'></a>
### Перемещение монстров

Функция `play` также перемещает монстров-капель, удерживает их
внутри стен подземелья и проверяет каждую на предмет столкновения с
игроком. Если капля врезается в верхнюю или нижнюю стены темницы, ее
направление инвертируется. Все это делается с помощью цикла `forEach`
который проходит через каждый из `blob` спрайтов в массиве `blobs` каждый кадр.

```js
blobs.forEach(function(blob) {

  //Move the blob
  blob.y += blob.vy;

  //Проверьте границы экрана блоба
  let blobHitsWall = contain(blob, {x: 28, y: 10, width: 488, height: 480});

  //Если капля попадает в верхнюю или нижнюю часть сцены, реверсим ее направление
  if (blobHitsWall === "top" || blobHitsWall === "bottom") {
    blob.vy *= -1;
  }

  //Тест на столкновение. Если какой-либо из врагов касается проводника,
  // установите для ʻexplorerHit` значение `true`
  if(hitTestRectangle(explorer, blob)) {
    explorerHit = true;
  }
});

```

Вы можете видеть в этом коде выше, как возвращаемое значение `contain`
Функция используется для того, чтобы капли отскакивали от стен. Переменная
 `blobHitsWall` используется для захвата возвращаемого значения:

```js
let blobHitsWall = contain(blob, {x: 28, y: 10, width: 488, height: 480});
```

`blobHitsWall` обычно будет `undefined`. Но если капля попадает в
верхнюю стену, `blobHitsWall` будет иметь значение "top". Если капля попадает в
нижнюю стенку, `blobHitsWall` будет иметь ценность "bottom". Если
любой из этих случаев `true`, вы можете изменить направление капли
изменяя его скорость. Вот код, который это делает:

```js
if (blobHitsWall === "top" || blobHitsWall === "bottom") {
  blob.vy *= -1;
}
```

Умножение вертикальной скорости капли `vy` (vertical velocity) на `-1` перевернет
направление его движения.

<a id='checkingcollisions'></a>
### Проверка на столкновения

Код в приведенном выше цикле использует `hitTestRectangle`  чтобы понять
коснулся ли кто-либо из врагов исследователя.

```js
if(hitTestRectangle(explorer, blob)) {
  explorerHit = true;
}
```

Если `hitTestRectangle` возвращает `true`, это означает, что произошло столкновение
и переменная с именем `explorerHit` установлен на `true`. Если `explorerHit`
= `true`, функция `play` делает проводник полупрозрачным и уменьшает ширину `health` 
бара на 1 пиксель.

```js
if(explorerHit) {

  //Делаем проводник полупрозрачным
  explorer.alpha = 0.5;

  //уменьшаем ширину внутреннего прямоугольника шкалы здоровья на 1 пиксель.
  healthBar.outer.width -= 1;

} else {

  //Сделайте проводник полностью непрозрачным (непрозрачный) если не попал
  explorer.alpha = 1;
}

```

ЕСли  `explorerHit` = `false`, свойство `alpha` исследователя
поддерживается в 1, что делает его полностью непрозрачным.

Функция `play` также проверяет наличие столкновения между сокровищами
сундук и исследователь. Если есть попадание, `treasure` установлен на
положение исследователя с небольшим смещением. Это делает его похожим на
исследователь несет сокровище.

![Отображение текста](/examples/images/screenshots/29.png)

Вот код, который это делает:

```js
if (hitTestRectangle(explorer, treasure)) {
  treasure.x = explorer.x + 8;
  treasure.y = explorer.y + 8;
}
```

<a id='reachingexit'></a>
### Достижение выходной двери и завершение игры

Игра может закончиться двумя способами: вы можете выиграть, если у вас есть
сокровище к выходу, иначе вы можете проиграть, если у вас закончится здоровье.

Чтобы выиграть игру, сундук с сокровищами просто должен коснуться выходной двери. Если
это происходит, игра `state` устанавливается в `end`, и текст `message` отображает "You won".

```js
if (hitTestRectangle(treasure, door)) {
  state = end;
  message.text = "You won!";
}
```

Если у вас кончится здоровье, вы проиграете игру. Игровой `state` это также
установится в `end` и текст `message` отобразит "You Lost!"

```js
if (healthBar.outer.width < 0) {
  state = end;
  message.text = "You lost!";
}
```

Но что это значит?

```js
state = end;
```

Вы помните из предыдущих примеров, что `gameLoop` постоянно обновляет функцию, называемую
`state` 60 раз в секунду. Вот `gameLoop`который это делает:

```js
function gameLoop(delta){

  //Обновить текущее состояние игры:
  state(delta);
}
```

Вы также помните, что мы изначально устанавливали значение
`state` = `play`, вот почему функция `play` работает в цикле.
Устанавливая `state` в `end` мы сообщаем коду, что хотим
вызвать другую функцию, `end` для запуска в цикле.
В большой игре вы могли бы иметь `tileScene` state, и состояния для каждого уровня игры,
`leveOne`, `levelTwo` и `levelThree`.

Так что же это за функция `end`? Вот!

```js
function end() {
  gameScene.visible = false;
  gameOverScene.visible = true;
}
```

Он просто переворачивает видимость игровых сцен. Это то, что скрывает
в `gameScene` и отображает `gameOverScene` когда игра заканчивается.

Это действительно простой пример того, как переключить состояние игры, но
вы можете иметь столько игровых состояний, сколько хотите, и заполнять их
с таким количеством кода, которое вам нужно. Просто измените значение `state` на
любую функцию, которую вы хотите запустить в цикле.

И это действительно все, что нужно для Treasure Hunter!
Немного поработав, вы сможете превратить этот простой прототип 
в полноценную игру - попробуйте!

<a id='spriteproperties'></a>
Подробнее о спрайтах
--------------------

Вы уже научились использовать несколько полезных свойств спрайтов, например `x`, `y`,
`visible`, и `rotation` которые дают вам полный контроль над
положением и внешним видом спрайта. Но у Pixi Sprites есть еще много
полезных свойства, с которыми весело играть. [Вот полный список.](http://pixijs.download/release/docs/PIXI.Sprite.html)

Как работает система наследования классов Pixi? ([Что такое **class**
и что есть **inheritance**? Щелкните эту ссылку, чтобы узнать.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript)) Спрайты Pixi
построена на модели наследования, которая следует этой цепочке:

```js
DisplayObject > Container > Sprite
```

Наследование просто означает, что классы позже в цепочке используют
свойства и методы из классов ранее в цепочке.
Это означает, что даже если `Sprite` это последний класс в цепочке,
имеет все те же свойства, что и `DisplayObject` и `Container`,
в дополнение к своим уникальным свойствам.
Самый простой класс `DisplayObject`. Все, что есть
`DisplayObject` может быть поставлен на сцене. `Container`
это следующий класс в цепочке наследования. Это позволяет `DisplayObject`
действовать как контейнеры для других `DisplayObject`.
Третье место в цепочкеe у класса `Sprite`.
Спрайты могут как отображаться на сцене, так и быть контейнерами для других спрайтов.

<a id='takingitfurther'></a>
Продолжая
---------

Pixi может многое, но не все! Если хочешь начать
создавать игры или сложные интерактивные приложения с Pixi вам понадобится
использовать вспомогательные библиотеки:

- [Bump](https://github.com/kittykatattack/bump): Полный набор функций 2D-столкновений для игр.
- [Tink](https://github.com/kittykatattack/tink): Drag-and-drop, кнопки, универсальный указатель и др.
  полезные интерактивные инструменты.
- [Charm](https://github.com/kittykatattack/charm): Простые в использовании эффекты твин-анимации для спрайтов Pixi.
- [Dust](https://github.com/kittykatattack/dust): Эффекты частиц для создания таких вещей, как взрывы, огонь и магия.
- [Sprite Utilities](https://github.com/kittykatattack/spriteUtilities): Более простые и интуитивно понятные способы создавать и использовать спрайты Pixi, а также добавлять конечный автомат и
  проигрыватель анимации. Делает работу с Pixi намного интереснее.
- [Sound.js](https://github.com/kittykatattack/sound.js): Микробиблиотека для загрузки, управления и генерации звуковые и музыкальные эффекты. Все, что нужно для добавления звука в игры.
- [Smoothie](https://github.com/kittykatattack/smoothie): Сверхгладкая анимация спрайтов с использованием истинной дельта-временной интерполяции. Он также позволяет указать частоту кадров в секунду (кадров в секунду), с которой работает ваша игра или приложение, и полностью отделяет цикл рендеринга спрайтов от цикла логики приложения.

Вы можете узнать, как использовать все эти библиотеки с Pixi, в книге.
[Learn PixiJS](http://www.springer.com/us/book/9781484210956).

<a id='hexi'></a>
### Hexi

Вы хотите использовать все функции этих библиотек, но не
хотите хлопот по их интеграции? Воспользуйтесь **Hexi**: полная
среда разработки для создания игр и интерактивных
Приложения:

https://github.com/kittykatattack/hexi

В него входит лучшая версия Pixi (последняя **стабильная**) со всеми
этими библиотеками (и другими!) для простого и увлекательного способа создавать игры.
Hexi также позволяет получить доступ к глобальному объекту `PIXI` напрямую, так что ты можешь написать
низкоуровневый код Pixi непосредственно в приложении Hexi и, при желании, использовать столько или
столько дополнительных удобств Hexi, сколько вам нужно.

<a id='babylonjs'></a>
### BabylonJS

Pixi is great for 2D, but it can't do 3D. When you're ready to step into the third dimension, the most feature rich, easy-to-use 3D game development platform for the web is [BabylonJS](https://www.babylonjs.com). It's a great next step for taking your skills further.

<a id='supportingthisproject'></a>
Please help to support this project!
-------------------

Buy the book! Incredibly, someone actually paid me to finish writing this tutorial
and turn it into a book! 

[Learn PixiJS](http://www.springer.com/us/book/9781484210956)

(And it's not just some junky "e-book", but a real, heavy, paper book, published by Springer,
the world's largest publisher! That means you can invite your friends
over, set it on fire, and roast marshmallows!!) There's 80% more
content than what's in this tutorial, and it's
packed full of all the essential techniques you need to know to use
Pixi to make all kinds of interactive applications and games.

Узнайте, как:

- Создавть анимированных игровых персонажей.
- Создать полноценный плейер анимационных состояний.
- Динамически анимируйте линии и формы.
- Использовать мозаичные спрайты для бесконечной прокрутки параллакса.
- Использовать режимы наложения, фильтры, тонирование, маски, видео и текстуры рендеринга.
- Создавать контент для разных разрешений.
- Создавать интерактивные кнопки.
- Создавать гибкий интерфейс перетаскивания для Pixi.
- Создавать эффекты частиц.
- Создавать стабильную архитектурную модель программного обеспечения, которую можно масштабировать до любого размера.
- Создавать полные игры.

И, как бонус, весь код полностью написан на последней версии
JavaScript: ES6 / 2015. И хотя код книги основан на Pixi v3.x, все это прекрасно работает с последней версией Pixi 4.x!

Если вы хотите поддержать этот проект, пожалуйста, купите копию этой книги,
и купи еще один экземпляр для мамы!

Или сделайте щедрое пожертвование: http://www.msf.org
