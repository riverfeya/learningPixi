
Графические примитивы Pixi
--------------------------

Использование текстур изображений - один из самых полезных способов создания спрайтов,
но у Pixi также есть свои собственные низкоуровневые инструменты рисования. Вы можете использовать их чтобы
создавать прямоугольники, формы, линии, сложные многоугольники и текст. А также,
к счастью, он использует почти тот же API, что и [Canvas Drawing API](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Drawing_graphics_with_canvas) так,
если вы уже знакомы с холстом HTML5, то для вас в этом не будет ничего нового. Но большое преимущество в том, что, в отличие от Canvas Drawing API,
  фигуры, которые вы рисуете с помощью Pixi, обрабатываются WebGL на графическом процессоре. Pixi
  позволяет получить доступ ко всей этой неиспользованной мощности.
Давайте кратко рассмотрим, как создавать основные формы. Вот все
формы, которые мы создадим в следующем коде.
![Графические примитивы](/examples/images/screenshots/23.png)

<a id='rectangles'></a>
### Прямоугольники

Все формы создаются путем создания нового экземпляра Pixi класса
`Graphics` (`PIXI.Graphics`).

```js
let rectangle = new Graphics();
```

Используйте `beginFill` с шестнадцатеричным значением цветового кода, чтобы установить
цвет заливки прямоугольника. Вот как настроить его на голубой.

```js
rectangle.beginFill(0x66CCFF);
```

Если вы хотите придать фигуре очертание, используйте метод lineStyle. Вот
как придать прямоугольнику красный контур шириной 4 пикселя с помощью ʻalpha`
значение 1.

```js
rectangle.lineStyle(4, 0xFF3300, 1);
```

Используйте метод drawRect, чтобы нарисовать прямоугольник. Его четыре аргумента
это `x`,` y`, `width` и` height`.

```js
rectangle.drawRect(x, y, width, height);
```

Используйте `endFill` когда будете готовы.

```js
rectangle.endFill();
```

Это похоже на API рисования холста! Вот весь код, который вам нужен
нарисуйте прямоугольник, измените его положение и добавьте его на сцену.

```js
let rectangle = new Graphics();
rectangle.lineStyle(4, 0xFF3300, 1);
rectangle.beginFill(0x66CCFF);
rectangle.drawRect(0, 0, 64, 64);
rectangle.endFill();
rectangle.x = 170;
rectangle.y = 170;
app.stage.addChild(rectangle);

```

Этот код создает синий прямоугольник 64 на 64 с красной рамкой в ​​координатах x и y, равных 170..

<a id='circles'></a>
### Круги

Сделайте круг методом `drawCircle`. Его три аргумента: `x`, `y` и `radius`

```js
drawCircle(x, y, radius)
```

В отличие от прямоугольников и спрайтов, положение круга по осям x и y также является его
Центральной точкой. Вот как создать круг фиолетового цвета с радиусом 32 пикселя.

```js
let circle = new Graphics();
circle.beginFill(0x9966FF);
circle.drawCircle(0, 0, 32);
circle.endFill();
circle.x = 64;
circle.y = 130;
app.stage.addChild(circle);
```

<a id='ellipses'></a>
### Эллипсы

Pixi позволяет рисовать эллипсы в качестве альтернативы Canvas Drawing API.
методом drawEllipse.

```js
drawEllipse(x, y, width, height);
```

Положение x / y определяет верхний левый угол эллипса (представьте, что
эллипс окружен невидимой прямоугольной ограничивающей рамкой -
верхний левый угол этого поля будет представлять x / y эллипса
положение якоря). Вот желтый эллипс шириной 50 пикселей и высотой 20 пикселей.

```js
let ellipse = new Graphics();
ellipse.beginFill(0xFFFF00);
ellipse.drawEllipse(0, 0, 50, 20);
ellipse.endFill();
ellipse.x = 180;
ellipse.y = 130;
app.stage.addChild(ellipse);
```

<a id='roundedrect'></a>
### Скругленный прямоугольник

Pixi также позволяет создавать прямоугольники со скругленными углами
с помощью метода drawRoundedRect.
Последний аргумент, `cornerRadius` число в пикселях, которое
определяет, на сколько нужно закруглять углы.

```js
drawRoundedRect(x, y, width, height, cornerRadius)
```

Вот как сделать прямоугольник со скругленными углами с радиусом угла 10
пикселей.

```js
let roundBox = new Graphics();
roundBox.lineStyle(4, 0x99CCFF, 1);
roundBox.beginFill(0xFF9933);
roundBox.drawRoundedRect(0, 0, 84, 36, 10)
roundBox.endFill();
roundBox.x = 48;
roundBox.y = 190;
app.stage.addChild(roundBox);
```

<a id='lines'></a>

### Lines

В приведенных выше примерах вы видели, что метод lineStyle позволяет вам
определить линию. Вы можете использовать методы `moveTo` и `lineTo` для рисования
начальной и конечной точек линии, точно так же, как вы можете с Canvas
API рисования. Вот как нарисовать белую диагональную линию шириной 4 пикселя.

```js
let line = new Graphics();
line.lineStyle(4, 0xFFFFFF, 1);
line.moveTo(0, 0);
line.lineTo(80, 50);
line.x = 32;
line.y = 32;
app.stage.addChild(line);
```

`PIXI.Graphics` объекты, такие как линии, имеют значения x и y, просто
как спрайты, поэтому вы можете разместить их в любом месте сцены после
того как вы их нарисовали.

<a id='polygons'></a>

### Polygons

Вы можете соединять линии вместе и заливать их цветами, чтобы сделать сложные
фигуры с помощью метода `drawPolygon`. Аргумент drawPolygon - это
массив путей x/y точек, которые определяют положения каждой точки на
форма.

```js
let path = [
  point1X, point1Y,
  point2X, point2Y,
  point3X, point3Y
];

graphicsObject.drawPolygon(path);
```

`drawPolygon` соединит эти три точки вместе, чтобы получилась форма.
Вот как использовать drawPolygon для соединения трех линий
сделайте красный треугольник с синей каймой. Треугольник нарисован на
положение 0,0, а затем переместился на свое место на сцене, используя его
Свойства `x` и `y`.

```js
let triangle = new Graphics();
triangle.beginFill(0x66FF33);

//Используем `drawPolygon` чтобы определить треугольник как массив путей x/y позиций

triangle.drawPolygon([
    -32, 64,             //Первая точка
    32, 64,              //Вторая точка
    0, 0                 //Третья точка
]);

//Цвет заливки формы
triangle.endFill();

//Расположите треугольник после того, как вы его нарисовали.
//Положение треугольника x/y привязано к его первой точке на пути.
triangle.x = 180;
triangle.y = 22;

app.stage.addChild(triangle);
```

<a id='text'></a>

Отображение текста
------------------

Используйте объект `Text` (` PIXI.Text`) для отображения текста в рабочей области. В простейшей форме это можно сделать так:

```js
let message = new Text("Hello Pixi!");
app.stage.addChild(message);
```

На холсте отобразятся слова «Hello, Pixi». Объекты Pixi Text наследуются от класса Sprite, поэтому они
содержат все те же свойства, как `x`,` y`, `width`,` height`,
`alpha`, и `rotation`. Расположите и измените размер текста на сцене так же, как и любой другой спрайт. 
Например, вы можете использовать `position.set`, чтобы установить положение `x` и `y` в сообщении следующим образом:

```js
message.position.set(54, 96);
```

![Отображение текста](/examples/images/screenshots/24.png)

Это даст вам основной текст без стиля. Но если вы хотите стать красивее, используйте функцию Pixi TextStyle для определения пользовательского стиля текста. Вот как:

```js
let style = new TextStyle({
  fontFamily: "Arial",
  fontSize: 36,
  fill: "white",
  stroke: '#ff3300',
  strokeThickness: 4,
  dropShadow: true,
  dropShadowColor: "#000000",
  dropShadowBlur: 4,
  dropShadowAngle: Math.PI / 6,
  dropShadowDistance: 6,
});
```

Это создает новый объект `style` содержащий все стили текста, которые вы хотели бы использовать.
Полный список всех свойств стиля, которые вы можете использовать, [смотрите здесь](http://pixijs.download/release/docs/PIXI.TextStyle.html).

Чтобы применить стиль к тексту, добавьте объект `style` в качестве второго аргумента функции `Text`, например:

```js
let message = new Text("Hello Pixi!", style);
```

![Отображение текста](/examples/images/screenshots/24.5.png)

Если вы хотите изменить содержимое текстового объекта после того, как
создал его, используйте свойство `text`.

```js
message.text = "Text changed!";
```

Используйте свойство `style`, если вы хотите переопределить свойства стиля.

```js
message.style = {fill: "black", font: "16px PetMe64"};
```

Pixi создает текстовые объекты, используя Canvas Drawing API для
визуализациии текста на невидимом и временном элементе холста.
Затем он превращает холст в текстуру WebGL, чтобы он
можно отобразить на спрайт.
Вот почему цвет текста должен быть
завернутый в строку: это значение цвета Canvas Drawing API. Как и с
любыми значениями цвета холста, вы можете использовать слова для обозначения общих цветов, например
«Красный» или «зеленый», либо используйте значения rgba, hsla или шестнадцатеричные значения.

Pixi также может переносить длинные строки текста. Установите стиль текста wordWrap
для свойства true, а затем установите для wordWrapWidth максимальную длину.
в пикселях, что должна быть строка текста. Используйте свойство ʻalign`
для установки выравнивания для многострочного текста.

```js
message.style = {wordWrap: true, wordWrapWidth: 100, align: center};
```

(Note: `align` doesn't affect single line text.)

If you want to use a custom font file, use the CSS `@font-face` rule
to link the font file to the HTML page where your Pixi application is
running.

```js
@font-face {
  font-family: "fontFamilyName";
  src: url("fonts/fontFile.ttf");
}
```

Add this `@font-face` rule to your HTML page's CSS style sheet.

[Pixi also has support for bitmap
fonts](http://pixijs.download/release/docs/PIXI.extras.BitmapText.html). You
can use Pixi's loader to load Bitmap font XML files, the same way you
load JSON or image files.

<a id='collision'></a>
Обнаружение столкновений
------------------------

Теперь вы знаете, как создавать огромное количество разнообразных графических объектов, но какие
ты можешь с ними делать? Самое интересное - построить простую систему **collision detection**.
Вы можете использовать настраиваемую функцию под названием `hitTestRectangle` это проверяет,
соприкасаются ли какие-либо два прямоугольных спрайта Pixi.

```js
hitTestRectangle(spriteOne, spriteTwo)
```

если они перекрываются, `hitTestRectangle` вернусь `true`. Вы можете использовать `hitTestRectangle` с оператор `if` для проверки столкновения двух таких спрайтов:

```js
if (hitTestRectangle(cat, box)) {
  //Есть столкновение
} else {
  //Нет столкновения
}
```

Как вы увидите, `hitTestRectangle` вход в огромную вселенную игрового дизайна.

Запустите файл `collisionDetection.html` в папке `examples`, для
рабочего примера использования `hitTestRectangle`. Используйте клавиши со стрелками
чтобы переместить кошку. Если кошка попадает в коробку, коробка становится красной.
и "Хит!" отображается текстовым объектом.

![Отображение текста](/examples/images/screenshots/25.png)

Вы уже видели весь код, который создает все эти элементы, например
а также система управления клавиатурой, которая заставляет кошку двигаться.
Единственное новое - это путь `hitTestRectangle` используется внутри функции `play`
для проверки на столкновение.

```js
function play(delta) {

  //использовать скорость кошки, чтобы заставить ее двигаться
  cat.x += cat.vx;
  cat.y += cat.vy;

  //проверить на столкновение между кошкой и ящиком
  if (hitTestRectangle(cat, box)) {

    //при столкновении измените текст сообщения и закрасьте поле красным
    message.text = "hit!";
    box.tint = 0xff3300;

  } else {

    //если нет коллизии, сбросить текст сообщения и цвет окна
    message.text = "No collision...";
    box.tint = 0xccff99;
  }
}
```

Поскольку функция play вызывается игровым циклом 60 раз
в секунду этот оператор `if` постоянно проверяет наличие столкновения
между кошкой и коробкой. Если `hitTestRectangle` имеет значение `true`,
Объект text `message` использует `text` для отображения "Hit":

```js
message.text = "Hit!";
```

Затем цвет рамки меняется с зеленого на красный, устанавливая
box значение свойства `tint` к шестнадцатеричному значению красного цвета.

```js
box.tint = 0xff3300;
```

Если коллизий нет, сообщение и окно остаются в своих
исходные состояния:

```js
message.text = "No collision...";
box.tint = 0xccff99;
```

Этот код довольно прост, но внезапно вы создали интерактивный
мир, который кажется полностью живым. Это почти похоже на волшебство! И, возможно
как ни странно, теперь у вас есть все навыки, необходимые, чтобы начать делать
игры с Pixi!

<a id='hittest'></a>
### Функция hitTestRectangle

Но как насчет функции `hitTestRectangle`? Что он делает, и
как это работает? Подробности того, как алгоритмы обнаружения столкновений
как эта работа немного выходит за рамки этого урока.
(Если вы действительно хотите знать, вы можете узнать, как в [этой книге](https://www.apress.com/us/book/9781430258001).)
Самое главное, чтобы вы знали, как им пользоваться. Но только для
ваш отзыв, и если вам интересно, вот полное определение функции `hitTestRectangle`.
Вы можете понять из комментариев, что она делает?

```js
function hitTestRectangle(r1, r2) {

  //Определите переменные, которые нам понадобятся для расчета
  let hit, combinedHalfWidths, combinedHalfHeights, vx, vy;

  //попадание определит, есть ли столкновение
  hit = false;

  //Найдите центральные точки каждого спрайта
  r1.centerX = r1.x + r1.width / 2;
  r1.centerY = r1.y + r1.height / 2;
  r2.centerX = r2.x + r2.width / 2;
  r2.centerY = r2.y + r2.height / 2;

  //Найдите полуширину и половину высоты каждого спрайта
  r1.halfWidth = r1.width / 2;
  r1.halfHeight = r1.height / 2;
  r2.halfWidth = r2.width / 2;
  r2.halfHeight = r2.height / 2;

  //Вычислить вектор расстояния между спрайтами
  vx = r1.centerX - r2.centerX;
  vy = r1.centerY - r2.centerY;

  //Определите комбинированные полуширины и полувысоты
  combinedHalfWidths = r1.halfWidth + r2.halfWidth;
  combinedHalfHeights = r1.halfHeight + r2.halfHeight;

  //Проверить наличие столкновения по оси x
  if (Math.abs(vx) < combinedHalfWidths) {

    //Может произойти столкновение. Проверьте наличие столкновения по оси Y
    if (Math.abs(vy) < combinedHalfHeights) {

      //Определенно происходит столкновение
      hit = true;
    } else {

      //На оси Y нет столкновения
      hit = false;
    }
  } else {

    //На оси x столкновения нет
    hit = false;
  }

  //`hit` будет либо `true` либо `false`
  return hit;
};

```

<a id='casestudy'></a>
Пример использования: Treasure Hunter
-------------------------------------

Я сказал вам, что теперь у вас есть все навыки, необходимые для начала
создание игр. Какой? Вы мне не верите? Позвольте мне доказать вам это! Давайте возьмем
закрыть, как сделать простую коллекцию объектов и врага
игра избегания называется **Treasure Hunter**. (You'll find it in the `examples`
folder.)

![Treasure Hunter](/examples/images/screenshots/26.png)

Treasure Hunter - хороший пример одного из самых простых полноценных
игр, которые вы можете создавать, используя уже изученные инструменты.
Использовать кнопки со стрелками на клавиатуре, чтобы помочь исследователю
найти клад и отнести его к выходу.
Шесть монстров-капель перемещаются между стенами подземелья, и если
они попадают в исследователя, он становится полупрозрачным, а индикатор здоровья
в правом верхнем углу сжимается.
Если все здоровье израсходовано, «Ты Погиб!" отображается на сцене;
если исследователь достигает выхода с сокровище "Вы выиграли!" отображается. Хотя это базовый
прототип, Treasure Hunter содержит большинство элементов, которые вы найдете
в гораздо более крупных играх: графика текстурного атласа, интерактивность,
столкновение и несколько игровых сцен. Давайте посмотрим, как
game была составлена ​​так, чтобы вы могли использовать ее в качестве отправной точки для одной из ваших собственных игр.

### Структура кода

Откройте файл `treasureHunter.html`, и вы увидите, что вся игра
код находится в одном большом файле. 
Вот как выглядит весь код с высоты птичьего полета.
организовано.

```js
//Настройте Pixi и загрузите файлы текстурного атласа - вызовите функцию `setup` когда они загрузились

function setup() {
  //Инициализируем игровые спрайты, установите состояние игры на `play`
  //и запустите `gameLoop`
}

function gameLoop(delta) {
  //Запускаем текущий игровой `state` в loop и рендерим спрайты
}

function play(delta) {
  //Здесь происходит вся логика игры
}

function end() {
  //Весь код, который должен запускаться в конце игры
}

//Вспомогательные функции игры:
//`keyboard`, `hitTestRectangle`, `contain` и `randomInt`
```

Используйте это как карту мира в игре, поскольку мы рассмотрим,
как работает каждая секция.

<a id='initialize'></a>
### Инициализация игры в функции setup

Как только изображения атласа текстур загружены, запускается функция `setup`.
Она запускается только один раз и позволяет вам выполнять
одноразовые задания по настройке вашей игры.
Это отличное место для создания и инициализации объектов, спрайтов, игровых сцен,
заполнение массивов данных или анализа загруженых данных игры в формате JSON.

Вот сокращенный вид функции `setup` в Treasure Hunter,
и задачи, которые он выполняет.

```js
function setup() {
  //Create the `gameScene` group
  //Create the `door` sprite
  //Create the `player` sprite
  //Create the `treasure` sprite
  //Make the enemies
  //Create the health bar
  //Add some text for the game over message
  //Create a `gameOverScene` group
  //Assign the player's keyboard controllers

  //set the game state to `play`
  state = play;

  //Start the game loop 
  app.ticker.add(delta => gameLoop(delta));
}

```

Tон последние две строки кода, `state = play;` и `gameLoop()` возможно
самое важное. Добавление `gameLoop` в тикер Pixi включает движок игры.,
и вызывает функцию `play` в непрерывном цикле. Но прежде чем мы посмотрим,
как это работает, давайте посмотрим, что делает специальный код внутри функции `setup` .

<a id='gamescene'></a>
#### Создание игровых сцен

Функция `setup` создает две группы `Container`, называемые
`gameScene` и `gameOverScene`. Каждый из них добавляется на сцену.

```js
gameScene = new Container();
app.stage.addChild(gameScene);

gameOverScene = new Container();
app.stage.addChild(gameOverScene);

```

Все спрайты, которые являются частью основной игры, добавляются в
группа `gameScene`. Текст game over который должен отображаться в
конец игры добавлен в группу `gameOverScene`.

![Отображение текста](/examples/images/screenshots/27.png)

Хотя он создается в функции `setup`, `gameOverScene`
не должен быть виден при первом запуске игры, его `visible`
свойство инициализируется значением `false`.

```js
gameOverScene.visible = false;
```

Вы увидите его, когда игра закончится, свойство `gameOverScene` - `visible`
будет установлено на `true` для отображения текста, который появляется в
конец игры.

<a id='makingdungon'></a>
#### Изготовление темницы, двери, исследователя и сокровища

Игрок, выходная дверь, сундук с сокровищами и темница фоновое изображение
все спрайты сделаны из фреймов текстурного атласа. Очень важно,
все они добавлены как дети `gameScene`.

```js
//Создайте псевдоним для идентификаторов кадров атласа текстур
id = resources["images/treasureHunter.json"].textures;

//Dungeon
dungeon = new Sprite(id["dungeon.png"]);
gameScene.addChild(dungeon);

//Door
door = new Sprite(id["door.png"]);
door.position.set(32, 0);
gameScene.addChild(door);

//Explorer
explorer = new Sprite(id["explorer.png"]);
explorer.x = 68;
explorer.y = gameScene.height / 2 - explorer.height / 2;
explorer.vx = 0;
explorer.vy = 0;
gameScene.addChild(explorer);

//Treasure
treasure = new Sprite(id["treasure.png"]);
treasure.x = gameScene.width - treasure.width - 48;
treasure.y = gameScene.height / 2 - treasure.height / 2;
gameScene.addChild(treasure);
```

Сохраняя их вместе в группе `gameScene` облегчит
нам скрытие `gameScene` и отображение `gameOverScene` когда игра закончена.

<a id='makingblob'></a>
#### Создание монстров - капель (blob monsters)

Шесть монстров-капель созданы в цикле. Каждому BLOB-объекту дается
случайное начальное положение и скорость. Вертикальная скорость
поочередно умножается на `1` или `-1` для каждой капли, и вот что
заставляет каждую каплю двигаться в направлении, противоположном тому,
что находится рядом с ним. Каждый созданный монстр blob помещается в массив с именем
`blobs`.

```js
let numberOfBlobs = 6,
    spacing = 48,
    xOffset = 150,
    speed = 2,
    direction = 1;

//Массив для хранения всех монстров-капель
blobs = [];

//Сделайте столько капель, сколько есть `numberOfBlobs`
for (let i = 0; i < numberOfBlobs; i++) {

  //Сделать каплю
  let blob = new Sprite(id["blob.png"]);

  //Разместите каждую каплю по горизонтали в соответствии со значением `spacing`.
  //`xOffset` определяет точку слева на экране, в которую должен быть добавлен первый blob
  let x = spacing * i + xOffset;

  //Дайте капле случайную `y` позицию
  let y = randomInt(0, stage.height - blob.height);

  //Установите положение капли
  blob.x = x;
  blob.y = y;

  //Установите вертикальную скорость капли. direction будет либо 1, либо
  //`-1`. `1` означает, что враг пойдет вниз и `-1` означает, что капля будет
  //двигаться вверх. Умножение `direction` на `speed` определяет вертикальное
  // направление капли
  blob.vy = speed * direction;

  //Изменить направление следующей капли
  direction *= -1;

  //Поместите blob в массив `blobs`
  blobs.push(blob);

  //Добавьте каплю в `gameScene`
  gameScene.addChild(blob);
}

```

<a id='healthbar'></a>
#### Делаем полоску здоровья

Когда вы играете в «Охотник за сокровищами», вы заметите, что когда исследователь касается
один из врагов, ширина шкалы здоровья вверху справа
угол экрана уменьшается. Как была сделана эта полоска здоровья? Это
всего два перекрывающихся прямоугольника в одной и той же позиции: черный прямоугольник сзади, и
красный прямоугольник спереди. Они сгруппированы в одну группу `healthBar`.
`healthBar` затем добавляется к `gameScene` и позиционируется на сцене.

```js
//Создайте полосу здоровья
healthBar = new PIXI.Container();
healthBar.position.set(stage.width - 170, 4)
gameScene.addChild(healthBar);

//Создайте прямоугольник на черном фоне
let innerBar = new PIXI.Graphics();
innerBar.beginFill(0x000000);
innerBar.drawRect(0, 0, 128, 8);
innerBar.endFill();
healthBar.addChild(innerBar);

//Создайте передний красный прямоугольник
let outerBar = new PIXI.Graphics();
outerBar.beginFill(0xFF3300);
outerBar.drawRect(0, 0, 128, 8);
outerBar.endFill();
healthBar.addChild(outerBar);

healthBar.outer = outerBar;
```

Вы можете видеть, что свойство под названием `outer` был добавлен в
`healthBar`. Он просто ссылается на `outerBar` (красный прямоугольник)
so что потом будет удобно получить доступ.

```js
healthBar.outer = outerBar;
```

Вам не нужно этого делать; но, эй, почему бы и нет! Значит, если хочешь
контролировать ширину красного `outerBar`, вы можете написать гладкий код, который выглядит так:

```js
healthBar.outer.width = 30;
```

Это довольно аккуратно и удобно для чтения, так что мы сохраним его!

<a id='message'></a>
#### Создание текста сообщения

Когда игра закончится, появится текст «Вы выиграли!» или ты
проиграл! », в зависимости от исхода игры. Это сделано с помощью
текстовый спрайт и добавив его в `gameOverScene`. Поскольку свойство
`visible` контейнера `gameOverScene` установлено в `false` при старте игры,
вы не видите этот текст. Вот код из функции `setup` который создает
текст сообщения и добавляет его в `gameOverScene`.

```js
let style = new TextStyle({
    fontFamily: "Futura",
    fontSize: 64,
    fill: "white"
  });
message = new Text("The End!", style);
message.x = 120;
message.y = app.stage.height / 2 - 32;
gameOverScene.addChild(message);
```

<a id='playing'></a>
### Играем в игру

Вся логика игры и код, который заставляет спрайты двигаться, происходят
внутри функции `play`, который работает в непрерывном цикле. Вот
обзор того, что делает функция `play`.

```js
function play(delta) {
  //Переместите исследователя и удерживайте его внутри подземелья
  //Переместите монстров-капель
  //Проверьте наличие столкновения между каплями и проводником
  //Проверьте, нет ли столкновения между исследователем и сокровищем
  //Проверьте, нет ли столкновения между сокровищем и дверью
  //Решите, выиграна игра или проиграна
  //Измените состояние игры на ʻend`, когда игра закончится
}
```

Давайте узнаем, как работают все эти функции.

<a id='movingexplorer'></a>
### Перемещение исследователя

Проводник управляется с клавиатуры, а код,
это очень похоже на код управления клавиатурой, который вы узнали ранее.
Объекты `keyboard` изменяют скорость проводника, и это
скорость добавляется к позиции исследователя внутри `play`
функция.

```js
explorer.x += explorer.vx;
explorer.y += explorer.vy;
```

<a id='containingmovement'></a>
#### Сдерживание движения

Но что нового, так это то, что движение исследователя заключено в стенах
подземелье. Зеленый контур показывает пределы возможностей исследователя.
движение.

![Отображение текста](/examples/images/screenshots/28.png)

Это делается с помощью специальной функции, называемой
`contain`.

```js
contain(explorer, {x: 28, y: 10, width: 488, height: 480});
```

`contain` принимает два аргумента. Первый - это спрайт, который вы хотите сохранить
содержится. Второй - любой объект со свойствами `x`, `y`, `width` и
`height` которые определяют прямоугольную область. В этом примере
содержащий объект определяет область, которая немного смещена
от сцены и меньше ее. Он соответствует размерам темницы
стены.

Вот функция `contain`, которая выполняет всю эту работу. Функция проверяет
чтобы увидеть, пересек ли спрайт границы содержащего
объект. Если да, код перемещает спрайт обратно в эту границу.
Функция `contain` также возвращает переменную `collision` с
значение "сверху", "справа", "снизу" или "слева", в зависимости от того, с какой стороны
граница, на которую попал спрайт. (`collision` будет `undefined` если
спрайт не попал ни в одну из границ.)

```js
function contain(sprite, container) {

  let collision = undefined;

  //Left
  if (sprite.x < container.x) {
    sprite.x = container.x;
    collision = "left";
  }

  //Top
  if (sprite.y < container.y) {
    sprite.y = container.y;
    collision = "top";
  }

  //Right
  if (sprite.x + sprite.width > container.width) {
    sprite.x = container.width - sprite.width;
    collision = "right";
  }

  //Bottom
  if (sprite.y + sprite.height > container.height) {
    sprite.y = container.height - sprite.height;
    collision = "bottom";
  }

  //Return the `collision` value
  return collision;
}
```

Вы увидите, как в коде будет использоваться возвращаемое значение `collision`.
впереди, чтобы монстры-капли подпрыгивали между вершинами
и нижние стены подземелья.

<a id='movingmonsters'></a>
### Перемещение монстров

Функция `play` также перемещает монстров-капель, удерживает их
внутри стен подземелья и проверяет каждую на предмет столкновения с
игроком. Если капля врезается в верхнюю или нижнюю стены темницы, ее
направление инвертируется. Все это делается с помощью цикла `forEach`
который проходит через каждый из `blob` спрайтов в массиве `blobs` каждый кадр.

```js
blobs.forEach(function(blob) {

  //Move the blob
  blob.y += blob.vy;

  //Проверьте границы экрана блоба
  let blobHitsWall = contain(blob, {x: 28, y: 10, width: 488, height: 480});

  //Если капля попадает в верхнюю или нижнюю часть сцены, реверсим ее направление
  if (blobHitsWall === "top" || blobHitsWall === "bottom") {
    blob.vy *= -1;
  }

  //Тест на столкновение. Если какой-либо из врагов касается проводника,
  // установите для ʻexplorerHit` значение `true`
  if(hitTestRectangle(explorer, blob)) {
    explorerHit = true;
  }
});

```

Вы можете видеть в этом коде выше, как возвращаемое значение `contain`
Функция используется для того, чтобы капли отскакивали от стен. Переменная
 `blobHitsWall` используется для захвата возвращаемого значения:

```js
let blobHitsWall = contain(blob, {x: 28, y: 10, width: 488, height: 480});
```

`blobHitsWall` обычно будет `undefined`. Но если капля попадает в
верхнюю стену, `blobHitsWall` будет иметь значение "top". Если капля попадает в
нижнюю стенку, `blobHitsWall` будет иметь ценность "bottom". Если
любой из этих случаев `true`, вы можете изменить направление капли
изменяя его скорость. Вот код, который это делает:

```js
if (blobHitsWall === "top" || blobHitsWall === "bottom") {
  blob.vy *= -1;
}
```

Умножение вертикальной скорости капли `vy` (vertical velocity) на `-1` перевернет
направление его движения.

<a id='checkingcollisions'></a>
### Проверка на столкновения

Код в приведенном выше цикле использует `hitTestRectangle`  чтобы понять
коснулся ли кто-либо из врагов исследователя.

```js
if(hitTestRectangle(explorer, blob)) {
  explorerHit = true;
}
```

Если `hitTestRectangle` возвращает `true`, это означает, что произошло столкновение
и переменная с именем `explorerHit` установлен на `true`. Если `explorerHit`
= `true`, функция `play` делает проводник полупрозрачным и уменьшает ширину `health` 
бара на 1 пиксель.

```js
if(explorerHit) {

  //Делаем проводник полупрозрачным
  explorer.alpha = 0.5;

  //уменьшаем ширину внутреннего прямоугольника шкалы здоровья на 1 пиксель.
  healthBar.outer.width -= 1;

} else {

  //Сделайте проводник полностью непрозрачным (непрозрачный) если не попал
  explorer.alpha = 1;
}

```

ЕСли  `explorerHit` = `false`, свойство `alpha` исследователя
поддерживается в 1, что делает его полностью непрозрачным.

Функция `play` также проверяет наличие столкновения между сокровищами
сундук и исследователь. Если есть попадание, `treasure` установлен на
положение исследователя с небольшим смещением. Это делает его похожим на
исследователь несет сокровище.

![Отображение текста](/examples/images/screenshots/29.png)

Вот код, который это делает:

```js
if (hitTestRectangle(explorer, treasure)) {
  treasure.x = explorer.x + 8;
  treasure.y = explorer.y + 8;
}
```

<a id='reachingexit'></a>
### Достижение выходной двери и завершение игры

Игра может закончиться двумя способами: вы можете выиграть, если у вас есть
сокровище к выходу, иначе вы можете проиграть, если у вас закончится здоровье.

Чтобы выиграть игру, сундук с сокровищами просто должен коснуться выходной двери. Если
это происходит, игра `state` устанавливается в `end`, и текст `message` отображает "You won".

```js
if (hitTestRectangle(treasure, door)) {
  state = end;
  message.text = "You won!";
}
```

Если у вас кончится здоровье, вы проиграете игру. Игровой `state` это также
установится в `end` и текст `message` отобразит "You Lost!"

```js
if (healthBar.outer.width < 0) {
  state = end;
  message.text = "You lost!";
}
```

Но что это значит?

```js
state = end;
```

Вы помните из предыдущих примеров, что `gameLoop` постоянно обновляет функцию, называемую
`state` 60 раз в секунду. Вот `gameLoop`который это делает:

```js
function gameLoop(delta){

  //Обновить текущее состояние игры:
  state(delta);
}
```

Вы также помните, что мы изначально устанавливали значение
`state` = `play`, вот почему функция `play` работает в цикле.
Устанавливая `state` в `end` мы сообщаем коду, что хотим
вызвать другую функцию, `end` для запуска в цикле.
В большой игре вы могли бы иметь `tileScene` state, и состояния для каждого уровня игры,
`leveOne`, `levelTwo` и `levelThree`.

Так что же это за функция `end`? Вот!

```js
function end() {
  gameScene.visible = false;
  gameOverScene.visible = true;
}
```

Он просто переворачивает видимость игровых сцен. Это то, что скрывает
в `gameScene` и отображает `gameOverScene` когда игра заканчивается.

Это действительно простой пример того, как переключить состояние игры, но
вы можете иметь столько игровых состояний, сколько хотите, и заполнять их
с таким количеством кода, которое вам нужно. Просто измените значение `state` на
любую функцию, которую вы хотите запустить в цикле.

И это действительно все, что нужно для Treasure Hunter!
Немного поработав, вы сможете превратить этот простой прототип 
в полноценную игру - попробуйте!

<a id='spriteproperties'></a>
Подробнее о спрайтах
--------------------

Вы уже научились использовать несколько полезных свойств спрайтов, например `x`, `y`,
`visible`, и `rotation` которые дают вам полный контроль над
положением и внешним видом спрайта. Но у Pixi Sprites есть еще много
полезных свойства, с которыми весело играть. [Вот полный список.](http://pixijs.download/release/docs/PIXI.Sprite.html)

Как работает система наследования классов Pixi? ([Что такое **class**
и что есть **inheritance**? Щелкните эту ссылку, чтобы узнать.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript)) Спрайты Pixi
построена на модели наследования, которая следует этой цепочке:

```js
DisplayObject > Container > Sprite
```

Наследование просто означает, что классы позже в цепочке используют
свойства и методы из классов ранее в цепочке.
Это означает, что даже если `Sprite` это последний класс в цепочке,
имеет все те же свойства, что и `DisplayObject` и `Container`,
в дополнение к своим уникальным свойствам.
Самый простой класс `DisplayObject`. Все, что есть
`DisplayObject` может быть поставлен на сцене. `Container`
это следующий класс в цепочке наследования. Это позволяет `DisplayObject`
действовать как контейнеры для других `DisplayObject`.
Третье место в цепочкеe у класса `Sprite`.
Спрайты могут как отображаться на сцене, так и быть контейнерами для других спрайтов.

<a id='takingitfurther'></a>
Продолжая
---------

Pixi может многое, но не все! Если хочешь начать
создавать игры или сложные интерактивные приложения с Pixi вам понадобится
использовать вспомогательные библиотеки:

- [Bump](https://github.com/kittykatattack/bump): Полный набор функций 2D-столкновений для игр.
- [Tink](https://github.com/kittykatattack/tink): Drag-and-drop, кнопки, универсальный указатель и др.
  полезные интерактивные инструменты.
- [Charm](https://github.com/kittykatattack/charm): Простые в использовании эффекты твин-анимации для спрайтов Pixi.
- [Dust](https://github.com/kittykatattack/dust): Эффекты частиц для создания таких вещей, как взрывы, огонь и магия.
- [Sprite Utilities](https://github.com/kittykatattack/spriteUtilities): Более простые и интуитивно понятные способы создавать и использовать спрайты Pixi, а также добавлять конечный автомат и
  проигрыватель анимации. Делает работу с Pixi намного интереснее.
- [Sound.js](https://github.com/kittykatattack/sound.js): Микробиблиотека для загрузки, управления и генерации звуковые и музыкальные эффекты. Все, что нужно для добавления звука в игры.
- [Smoothie](https://github.com/kittykatattack/smoothie): Сверхгладкая анимация спрайтов с использованием истинной дельта-временной интерполяции. Он также позволяет указать частоту кадров в секунду (кадров в секунду), с которой работает ваша игра или приложение, и полностью отделяет цикл рендеринга спрайтов от цикла логики приложения.

Вы можете узнать, как использовать все эти библиотеки с Pixi, в книге.
[Learn PixiJS](http://www.springer.com/us/book/9781484210956).

<a id='hexi'></a>
### Hexi

Вы хотите использовать все функции этих библиотек, но не
хотите хлопот по их интеграции? Воспользуйтесь **Hexi**: полная
среда разработки для создания игр и интерактивных
Приложения:

https://github.com/kittykatattack/hexi

В него входит лучшая версия Pixi (последняя **стабильная**) со всеми
этими библиотеками (и другими!) для простого и увлекательного способа создавать игры.
Hexi также позволяет получить доступ к глобальному объекту `PIXI` напрямую, так что ты можешь написать
низкоуровневый код Pixi непосредственно в приложении Hexi и, при желании, использовать столько или
столько дополнительных удобств Hexi, сколько вам нужно.

<a id='babylonjs'></a>
### BabylonJS

Pixi is great for 2D, but it can't do 3D. When you're ready to step into the third dimension, the most feature rich, easy-to-use 3D game development platform for the web is [BabylonJS](https://www.babylonjs.com). It's a great next step for taking your skills further.

<a id='supportingthisproject'></a>
Please help to support this project!
-------------------

Buy the book! Incredibly, someone actually paid me to finish writing this tutorial
and turn it into a book! 

[Learn PixiJS](http://www.springer.com/us/book/9781484210956)

(And it's not just some junky "e-book", but a real, heavy, paper book, published by Springer,
the world's largest publisher! That means you can invite your friends
over, set it on fire, and roast marshmallows!!) There's 80% more
content than what's in this tutorial, and it's
packed full of all the essential techniques you need to know to use
Pixi to make all kinds of interactive applications and games.

Узнайте, как:

- Создавть анимированных игровых персонажей.
- Создать полноценный плейер анимационных состояний.
- Динамически анимируйте линии и формы.
- Использовать мозаичные спрайты для бесконечной прокрутки параллакса.
- Использовать режимы наложения, фильтры, тонирование, маски, видео и текстуры рендеринга.
- Создавать контент для разных разрешений.
- Создавать интерактивные кнопки.
- Создавать гибкий интерфейс перетаскивания для Pixi.
- Создавать эффекты частиц.
- Создавать стабильную архитектурную модель программного обеспечения, которую можно масштабировать до любого размера.
- Создавать полные игры.

И, как бонус, весь код полностью написан на последней версии
JavaScript: ES6 / 2015. И хотя код книги основан на Pixi v3.x, все это прекрасно работает с последней версией Pixi 4.x!

Если вы хотите поддержать этот проект, пожалуйста, купите копию этой книги,
и купи еще один экземпляр для мамы!

Или сделайте щедрое пожертвование: http://www.msf.org
